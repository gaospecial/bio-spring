<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>GitHub on BIO-SPRING</title>
    <link>bio-spring/tags/github/</link>
    <description>Recent content in GitHub on BIO-SPRING</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Mon, 11 Nov 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="bio-spring/tags/github/" rel="self" type="application/rss+xml" />

    
      <item>
        <title>配置私有 Git LFS 服务器</title>
        <link>bio-spring/post/2024/11/11/private-git-lfs-server/</link>
        <pubDate>Mon, 11 Nov 2024 00:00:00 +0000</pubDate>
        <author>gaoch</author>
        <guid>bio-spring/post/2024/11/11/private-git-lfs-server/</guid>
        <description>
          &lt;p&gt;在 Git 项目中使用大文件已经成为非常普遍的事情了，例如在 Hugging face 下面的仓库中这样的情况比比皆是。&lt;/p&gt;
&lt;p&gt;为了能够“专业地”存储大文件，或许可以有以下几种方式：&lt;/p&gt;
&lt;h2 id=&#34;使用-nas-服务器&#34;&gt;使用 NAS 服务器&lt;/h2&gt;
&lt;p&gt;要将 NAS 作为 Git LFS 服务器，关键是让 NAS 提供 HTTP 或 SSH 文件存储服务，并将其作为 LFS 对象的存储端点。具体步骤如下：&lt;/p&gt;
&lt;h3 id=&#34;1-在-nas-上设置文件存储服务&#34;&gt;1. 在 NAS 上设置文件存储服务&lt;/h3&gt;
&lt;p&gt;确保 NAS 服务器支持 HTTP、HTTPS 或 SSH 服务，以便用于存储 LFS 对象。以下是常见设置方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;HTTP/HTTPS&lt;/strong&gt;：如果 NAS 支持 Web 服务器功能，可以配置一个虚拟主机用于存储 LFS 对象。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SSH&lt;/strong&gt;：确保 SSH 服务已启用，并为 LFS 服务器创建一个专门用户。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-初始化-git-仓库&#34;&gt;2. 初始化 Git 仓库&lt;/h3&gt;
&lt;p&gt;在本地创建或初始化一个 Git 仓库，并使用 &lt;code&gt;git lfs&lt;/code&gt; 初始化 LFS 配置：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git init
git lfs install
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3-配置-lfs-远程端点&#34;&gt;3. 配置 LFS 远程端点&lt;/h3&gt;
&lt;p&gt;将 LFS 端点配置为 NAS 的 HTTP 或 SSH 地址。编辑 &lt;code&gt;.lfsconfig&lt;/code&gt; 文件，并添加以下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[lfs]
url = &amp;quot;http://&amp;lt;NAS_IP&amp;gt;/path/to/lfs&amp;quot;   # 使用 HTTP/HTTPS
# url = &amp;quot;ssh://user@&amp;lt;NAS_IP&amp;gt;/path/to/lfs&amp;quot;  # 使用 SSH
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将 &lt;code&gt;&amp;lt;NAS_IP&amp;gt;&lt;/code&gt; 替换为 NAS 的 IP 地址，&lt;code&gt;path/to/lfs&lt;/code&gt; 为存储 LFS 对象的目录路径。&lt;/p&gt;
&lt;h3 id=&#34;4-上传-lfs-对象&#34;&gt;4. 上传 LFS 对象&lt;/h3&gt;
&lt;p&gt;在配置好 NAS 地址后，添加大文件并推送到 LFS：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git lfs track &amp;quot;*.largefile&amp;quot;
git add .gitattributes
git add &amp;lt;large_file&amp;gt;
git commit -m &amp;quot;Add large file&amp;quot;
git push origin main
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;5-测试-lfs-存储&#34;&gt;5. 测试 LFS 存储&lt;/h3&gt;
&lt;p&gt;通过 NAS 的管理界面或命令行确认文件已存储到 LFS 目录。&lt;/p&gt;
&lt;h2 id=&#34;使用阿里云的-oss-存储服务&#34;&gt;使用阿里云的 OSS 存储服务&lt;/h2&gt;
&lt;p&gt;要将阿里云作为 Git LFS 文件服务器，可以使用阿里云对象存储 OSS (Object Storage Service) 来存储 LFS 对象。这里是具体的配置步骤：&lt;/p&gt;
&lt;h3 id=&#34;1-开通-oss-服务&#34;&gt;1. 开通 OSS 服务&lt;/h3&gt;
&lt;p&gt;在阿里云控制台开通 OSS 服务并创建一个存储桶 (Bucket)，用于存放 Git LFS 对象。&lt;/p&gt;
&lt;h3 id=&#34;2-创建访问密钥&#34;&gt;2. 创建访问密钥&lt;/h3&gt;
&lt;p&gt;前往阿里云控制台的 &lt;strong&gt;访问控制&lt;/strong&gt;（RAM），创建一个专用用户，并生成访问密钥（Access Key ID 和 Access Key Secret），授予 OSS 的读写权限。&lt;/p&gt;
&lt;h3 id=&#34;3-配置-oss-存储桶权限&#34;&gt;3. 配置 OSS 存储桶权限&lt;/h3&gt;
&lt;p&gt;将 OSS 存储桶设置为私有，以确保数据安全。然后，您可以选择通过 &lt;strong&gt;OSS 签名 URL&lt;/strong&gt; 或 &lt;strong&gt;自定义的 API&lt;/strong&gt; 访问这些文件。&lt;/p&gt;
&lt;h3 id=&#34;4-配置-git-lfs-指向-oss&#34;&gt;4. 配置 Git LFS 指向 OSS&lt;/h3&gt;
&lt;p&gt;Git LFS 本身不支持直接与 OSS 交互，所以需要通过 LFS 代理来实现，例如 &lt;a href=&#34;https://github.com/git-lfs/lfs-test-server&#34;&gt;lfs-test-server&lt;/a&gt;。以下是主要配置步骤：&lt;/p&gt;
&lt;h4 id=&#34;a-在服务器上安装和配置-lfs-test-server&#34;&gt;a. 在服务器上安装和配置 lfs-test-server&lt;/h4&gt;
&lt;p&gt;将 lfs-test-server 部署到您的服务器上，并将其配置为中转 Git LFS 请求到 OSS。您可以使用 Docker 部署 lfs-test-server，命令如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker run -d -p 9999:8080 \
  -e LFS_BASE_URL=https://&amp;lt;your-domain&amp;gt;/lfs \
  -e LFS_AUTH=true \
  -e AWS_ACCESS_KEY_ID=&amp;lt;your-access-key-id&amp;gt; \
  -e AWS_SECRET_ACCESS_KEY=&amp;lt;your-access-key-secret&amp;gt; \
  -e LFS_STORE_DIR=/data \
  -v /path/to/data:/data \
  -e LFS_ENDPOINT=https://&amp;lt;oss-endpoint&amp;gt;/&amp;lt;bucket-name&amp;gt; \
  ghcr.io/git-lfs/lfs-test-server
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;替换以下参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;your-domain&amp;gt;&lt;/code&gt;：服务器域名或 IP 地址&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;your-access-key-id&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;your-access-key-secret&amp;gt;&lt;/code&gt;：阿里云的访问密钥&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;oss-endpoint&amp;gt;&lt;/code&gt;：OSS 终端，例如 &lt;code&gt;oss-cn-shanghai.aliyuncs.com&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;bucket-name&amp;gt;&lt;/code&gt;：OSS 存储桶名称&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;b-配置-git-lfs-使用代理&#34;&gt;b. 配置 Git LFS 使用代理&lt;/h4&gt;
&lt;p&gt;在 Git 仓库中创建或编辑 &lt;code&gt;.lfsconfig&lt;/code&gt; 文件，指向您服务器上配置的 lfs-test-server：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[lfs]
url = &amp;quot;https://&amp;lt;your-domain&amp;gt;/lfs&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;5-使用-git-lfs-推送和拉取文件&#34;&gt;5. 使用 Git LFS 推送和拉取文件&lt;/h3&gt;
&lt;p&gt;完成配置后，您可以像平常一样使用 Git LFS 进行文件的添加和推送：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git lfs track &amp;quot;*.largefile&amp;quot;
git add .gitattributes
git add &amp;lt;large_file&amp;gt;
git commit -m &amp;quot;Add large file&amp;quot;
git push origin main
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;6-测试-oss-存储&#34;&gt;6. 测试 OSS 存储&lt;/h3&gt;
&lt;p&gt;通过 OSS 控制台查看存储桶，确认文件已成功上传到 OSS。&lt;/p&gt;
&lt;h2 id=&#34;使用腾讯云的-cos-存储服务&#34;&gt;使用腾讯云的 COS 存储服务&lt;/h2&gt;
&lt;p&gt;要将腾讯云配置为 Git LFS 的服务器，可以使用腾讯云对象存储 COS (Cloud Object Storage) 来存储 Git LFS 对象。以下是具体的步骤：&lt;/p&gt;
&lt;h3 id=&#34;1-开通-cos-服务&#34;&gt;1. 开通 COS 服务&lt;/h3&gt;
&lt;p&gt;在腾讯云控制台开通 COS 服务，并创建一个存储桶 (Bucket) 来存储 Git LFS 对象。可以根据实际需求设置桶的访问权限为私有或公有读。&lt;/p&gt;
&lt;h3 id=&#34;2-获取访问密钥&#34;&gt;2. 获取访问密钥&lt;/h3&gt;
&lt;p&gt;前往腾讯云控制台的 &lt;strong&gt;访问管理&lt;/strong&gt;（CAM），创建一个新用户或使用已有用户，确保有 COS 读写权限，并获取该用户的 &lt;strong&gt;SecretId&lt;/strong&gt; 和 &lt;strong&gt;SecretKey&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;3-配置-cos-存储桶权限&#34;&gt;3. 配置 COS 存储桶权限&lt;/h3&gt;
&lt;p&gt;建议将 COS 存储桶的权限设置为私有，以确保数据安全。通过 COS 的签名 URL 或代理服务来实现 Git LFS 的访问控制。&lt;/p&gt;
&lt;h3 id=&#34;4-部署-git-lfs-服务器代理&#34;&gt;4. 部署 Git LFS 服务器代理&lt;/h3&gt;
&lt;p&gt;由于 Git LFS 本身无法直接与 COS 交互，需要部署一个 LFS 代理服务器来实现对 COS 的中转。可以使用 &lt;a href=&#34;https://github.com/git-lfs/lfs-test-server&#34;&gt;lfs-test-server&lt;/a&gt; 作为 Git LFS 的服务器代理。以下是具体步骤：&lt;/p&gt;
&lt;h4 id=&#34;a-安装和配置-lfs-test-server&#34;&gt;a. 安装和配置 lfs-test-server&lt;/h4&gt;
&lt;p&gt;在您的服务器上安装 &lt;code&gt;lfs-test-server&lt;/code&gt;，可以使用 Docker 快速部署：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker run -d -p 9999:8080 \
  -e LFS_BASE_URL=https://&amp;lt;your-domain&amp;gt;/lfs \
  -e LFS_AUTH=true \
  -e AWS_ACCESS_KEY_ID=&amp;lt;your-secret-id&amp;gt; \
  -e AWS_SECRET_ACCESS_KEY=&amp;lt;your-secret-key&amp;gt; \
  -e LFS_STORE_DIR=/data \
  -v /path/to/data:/data \
  -e LFS_ENDPOINT=https://&amp;lt;cos-endpoint&amp;gt;/&amp;lt;bucket-name&amp;gt; \
  ghcr.io/git-lfs/lfs-test-server
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;替换以下参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;your-domain&amp;gt;&lt;/code&gt;：服务器的域名或 IP 地址&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;your-secret-id&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;your-secret-key&amp;gt;&lt;/code&gt;：腾讯云的 SecretId 和 SecretKey&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;cos-endpoint&amp;gt;&lt;/code&gt;：COS 终端（例如 &lt;code&gt;cos.ap-guangzhou.myqcloud.com&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;bucket-name&amp;gt;&lt;/code&gt;：COS 存储桶名称&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;b-配置-git-lfs-使用代理-1&#34;&gt;b. 配置 Git LFS 使用代理&lt;/h4&gt;
&lt;p&gt;在 Git 仓库中创建或编辑 &lt;code&gt;.lfsconfig&lt;/code&gt; 文件，将 LFS 的 URL 配置为代理服务器地址：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[lfs]
url = &amp;quot;https://&amp;lt;your-domain&amp;gt;/lfs&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;5-添加大文件并推送到-lfs&#34;&gt;5. 添加大文件并推送到 LFS&lt;/h3&gt;
&lt;p&gt;完成配置后，可以像常规 Git LFS 操作一样，添加大文件并推送到 LFS：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git lfs track &amp;quot;*.largefile&amp;quot;
git add .gitattributes
git add &amp;lt;large_file&amp;gt;
git commit -m &amp;quot;Add large file&amp;quot;
git push origin main
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;6-验证-cos-存储&#34;&gt;6. 验证 COS 存储&lt;/h3&gt;
&lt;p&gt;在腾讯云 COS 控制台查看存储桶，确认 Git LFS 对象已成功上传至 COS。&lt;/p&gt;
&lt;h2 id=&#34;局部访问权限&#34;&gt;局部访问权限&lt;/h2&gt;
&lt;p&gt;在 GitHub Organization 内部公开的仓库中使用私有化的 OSS 存储，并希望仅对组织内具有仓库访问权限的成员开放 LFS 文件的访问，可以采用以下方法，以确保访问控制在组织范围内实现：&lt;/p&gt;
&lt;h3 id=&#34;1-使用-oss-的临时访问凭证和签名-url&#34;&gt;1. 使用 OSS 的临时访问凭证和签名 URL&lt;/h3&gt;
&lt;p&gt;利用阿里云 RAM（资源访问管理）中的 &lt;strong&gt;STS（Security Token Service）&lt;/strong&gt;，生成带有临时访问权限的签名 URL。这种方法适用于为每位有权限的组织成员提供有限时效的访问链接。&lt;/p&gt;
&lt;h4 id=&#34;设置步骤&#34;&gt;设置步骤：&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;配置 RAM 角色&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在阿里云控制台中，创建一个 RAM 角色，并授予该角色对 OSS 存储桶的读取权限。&lt;/li&gt;
&lt;li&gt;在 GitHub Actions 或其他自动化脚本中，使用该角色来生成签名 URL。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;使用 STS 生成临时签名 URL&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;利用阿里云 SDK 或 API 生成具有临时访问凭证的签名 URL。&lt;/li&gt;
&lt;li&gt;生成的 URL 可直接嵌入到 GitHub 的 README 或发布页面，但由于有时间限制，URL 可能需要定期刷新。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;示例 Python 代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import oss2
import time

# 使用 STS 获取临时访问凭证
auth = oss2.Auth(&#39;&amp;lt;AccessKeyId&amp;gt;&#39;, &#39;&amp;lt;AccessKeySecret&amp;gt;&#39;)
bucket = oss2.Bucket(auth, &#39;http://oss-cn-shanghai.aliyuncs.com&#39;, &#39;&amp;lt;bucket-name&amp;gt;&#39;)

# 设置有效期，单位为秒（如 3600 秒即 1 小时）
signed_url = bucket.sign_url(&#39;GET&#39;, &#39;path/to/largefile&#39;, 3600)
print(&amp;quot;Signed URL:&amp;quot;, signed_url)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;将签名 URL 提供给组织成员&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可在 GitHub Actions 中自动生成签名 URL，将其写入 README 或通知组织成员。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;2-使用-github-actions-动态生成访问权限&#34;&gt;2. 使用 GitHub Actions 动态生成访问权限&lt;/h3&gt;
&lt;p&gt;利用 GitHub Actions 在特定工作流中动态生成签名 URL，并通过 GitHub Secrets 管理 Access Key 信息。这样，组织内部访问者可以使用 Actions 生成的临时 URL。&lt;/p&gt;
&lt;h4 id=&#34;设置步骤-1&#34;&gt;设置步骤：&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;配置 GitHub Secrets&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在仓库设置中，将阿里云的 Access Key 和 Secret Key 添加为 Secrets。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;配置 GitHub Actions 工作流&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 GitHub Actions 定义一个工作流，生成签名 URL，供组织内成员访问。例如：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;name: Generate LFS Signed URL

on:
  workflow_dispatch:  # 手动触发工作流

jobs:
  generate-url:
    runs-on: ubuntu-latest
    steps:
      - name: Set up Python
        uses: actions/setup-python@v2
        with:
          python-version: &#39;3.x&#39;

      - name: Install oss2
        run: pip install oss2

      - name: Generate Signed URL
        env:
          ACCESS_KEY_ID: ${{ secrets.ACCESS_KEY_ID }}
          ACCESS_KEY_SECRET: ${{ secrets.ACCESS_KEY_SECRET }}
        run: |
          import oss2
          auth = oss2.Auth(&#39;${{ secrets.ACCESS_KEY_ID }}&#39;, &#39;${{ secrets.ACCESS_KEY_SECRET }}&#39;)
          bucket = oss2.Bucket(auth, &#39;http://oss-cn-shanghai.aliyuncs.com&#39;, &#39;bucket-name&#39;)
          signed_url = bucket.sign_url(&#39;GET&#39;, &#39;path/to/largefile&#39;, 3600)
          print(&amp;quot;Signed URL:&amp;quot;, signed_url)
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;通知组织成员&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;执行该工作流生成的 URL 可发布到 GitHub Issues、Wiki 或 README 中的受限访问部分。组织内具有仓库访问权限的成员即可使用该 URL。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;3-使用专用的-web-代理服务控制权限&#34;&gt;3. 使用专用的 Web 代理服务控制权限&lt;/h3&gt;
&lt;p&gt;部署一个内部 Web 代理服务来充当 Git LFS 文件访问的中介，通过组织成员的 GitHub 登录信息控制访问。该代理服务从 OSS 获取文件，并将其返回给经过验证的用户。&lt;/p&gt;
&lt;h4 id=&#34;设置步骤-2&#34;&gt;设置步骤：&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;构建 Web 代理&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用例如 OAuth 的 GitHub 登录认证方式来验证用户是否为组织成员。&lt;/li&gt;
&lt;li&gt;验证通过后，代理服务使用 Access Key 从 OSS 下载 LFS 文件，并提供下载服务。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;配置组织内用户访问&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将 Web 代理的 URL 公开在 GitHub 仓库中，供组织成员访问。&lt;/li&gt;
&lt;li&gt;该代理服务可根据用户请求动态生成签名 URL，并将文件传递给用户。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这种方法适合需要精细控制访问权限的情况。通过代理服务，只有组织成员能够访问文件内容，同时避免了将 OSS 存储桶直接公开。&lt;/p&gt;
&lt;h2 id=&#34;费用&#34;&gt;费用&lt;/h2&gt;
&lt;p&gt;云存储的存储、访问、取回都要收费。以阿里云为例，其 OSS 的费用主要包括以下几部分：&lt;/p&gt;
&lt;h3 id=&#34;1-存储费用&#34;&gt;1. 存储费用&lt;/h3&gt;
&lt;p&gt;存储费用基于存储在 OSS 中的数据量，按 GB 每月收费。价格因存储类型不同而异：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;标准存储&lt;/strong&gt;：适合频繁访问的数据，价格最高。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;低频访问存储&lt;/strong&gt;：适合不频繁访问的数据，价格较低，但有最低存储时间要求（通常为30天）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;归档存储&lt;/strong&gt;：适合长期备份的数据，价格更低，但有更长的存储时间要求，数据恢复速度较慢。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;冷归档存储&lt;/strong&gt;：适合极少访问的冷数据，价格最低，恢复数据可能需要数小时。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：如果文件存储在低频或归档类型中，但被频繁访问，额外的读取请求费用可能较高。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;2-请求费用&#34;&gt;2. 请求费用&lt;/h3&gt;
&lt;p&gt;请求费用基于对 OSS 的操作次数，包括上传、下载、删除等请求，按千次请求数计费。不同存储类型的请求费用略有差异。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;PUT、COPY、POST 和 LIST 请求&lt;/strong&gt;：上传或列出文件的请求收费较低。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GET 和 HEAD 请求&lt;/strong&gt;：读取文件的请求通常费用较高。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-数据传输费用&#34;&gt;3. 数据传输费用&lt;/h3&gt;
&lt;p&gt;数据传输费用指从 OSS 传出数据的费用。主要根据流量计费：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;出网流量&lt;/strong&gt;：从 OSS 下载数据到公网（例如下载到本地或其他网络）的流量按 GB 收费。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内网流量&lt;/strong&gt;：阿里云同一地域内的云服务间的数据传输通常免费，例如 OSS 与 ECS 实例在同一区域内传输数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;跨区域流量&lt;/strong&gt;：数据在不同地域间传输会收取费用，按 GB 计费。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4-数据处理费用可选&#34;&gt;4. 数据处理费用（可选）&lt;/h3&gt;
&lt;p&gt;如果使用 OSS 提供的附加功能（如图片处理、音视频转码），则会产生额外费用。这些费用基于处理请求的次数和数据量。&lt;/p&gt;
&lt;h3 id=&#34;费用示例&#34;&gt;费用示例&lt;/h3&gt;
&lt;p&gt;假设您使用 &lt;strong&gt;标准存储&lt;/strong&gt;，存储了 100 GB 数据，产生了 1,000 次上传请求和 1,000 次下载请求，并传输了 10 GB 数据到公网。大致费用如下（具体价格需参考阿里云官网最新信息）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;存储费用&lt;/strong&gt;：100 GB × 标准存储单价&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;请求费用&lt;/strong&gt;：1,000 PUT 请求 × 单价 + 1,000 GET 请求 × 单价&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;传输费用&lt;/strong&gt;：10 GB × 出网流量单价&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;阿里云 OSS 价格会随时更新，访问 &lt;a href=&#34;https://cn.aliyun.com/price/detail/oss?from_alibabacloud=&#34;&gt;阿里云 OSS 价格页面&lt;/a&gt; 获取最新和详细的费用信息。&lt;/p&gt;

        </description>
      </item>
    
      <item>
        <title>GitHub Webhook</title>
        <link>bio-spring/post/2024/11/04/github-webhook/</link>
        <pubDate>Mon, 04 Nov 2024 00:00:00 +0000</pubDate>
        <author>gaoch</author>
        <guid>bio-spring/post/2024/11/04/github-webhook/</guid>
        <description>
          &lt;p&gt;使用 GitHub Webhook 自动更新个人网站。&lt;a href=&#34;https://bio-spring.top&#34;&gt;bio-spring.top&lt;/a&gt; 是我的个人网站，其源代码托管在 &lt;a href=&#34;https://github.com/gaospecial/bio-spring&#34;&gt;GitHub&lt;/a&gt; 上。通过使用 GitHub Actions 可以自动构建网站并部署到 GitHub Pages，实现自动更新网站在 &lt;a href=&#34;https://gaospecial.github.io/bio-spring/&#34;&gt;gaospecial.github.io/bio-spring/&lt;/a&gt; 上的展示。通过使用 netlify 可以实现自动更新网站在 netlify 服务器上的展示。现在想要自动化部署到我的阿里云服务器上，该如何实现呢？&lt;/p&gt;
&lt;p&gt;这里要用到几个部分的技术：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GitHub Webhook&lt;/li&gt;
&lt;li&gt;配置 Hook server&lt;/li&gt;
&lt;li&gt;设置 Hook server 要执行的任务&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;配置-github-webhook&#34;&gt;配置 GitHub Webhook&lt;/h2&gt;
&lt;p&gt;GitHub Webhook 是一种自动化工具，它允许在 GitHub 仓库发生特定事件时向外部服务器发送通知。当配置的事件（如 push、pull request 等）发生时，GitHub 会向指定的 URL 发送 HTTP POST 请求，包含相关事件的详细信息。&lt;/p&gt;
&lt;h3 id=&#34;访问-webhook-设置&#34;&gt;访问 Webhook 设置&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;进入 GitHub 仓库&lt;/li&gt;
&lt;li&gt;点击 &amp;ldquo;Settings&amp;rdquo; 选项卡&lt;/li&gt;
&lt;li&gt;在左侧菜单中选择 &amp;ldquo;Webhooks&amp;rdquo;&lt;/li&gt;
&lt;li&gt;点击 &amp;ldquo;Add webhook&amp;rdquo; 按钮&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;配置-webhook&#34;&gt;配置 Webhook&lt;/h3&gt;
&lt;p&gt;在添加 Webhook 时需要设置以下内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Payload URL&lt;/strong&gt;: 接收 webhook 请求的服务器地址&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例如：&lt;code&gt;http://webhook.bio-spring.top/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;确保该 URL 可以从公网访问&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Content type&lt;/strong&gt;: 选择数据传输格式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通常选择 &lt;code&gt;application/json&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Secret&lt;/strong&gt;: 设置密钥（可选但推荐）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用于验证请求来源的合法性&lt;/li&gt;
&lt;li&gt;确保安全传输&lt;/li&gt;
&lt;li&gt;生成一个随机的秘钥字符串：&lt;code&gt;openssl rand -hex 20&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;事件触发选项&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&amp;ldquo;Just the push event&amp;rdquo;: 仅推送事件&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Send me everything&amp;rdquo;: 所有事件&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Let me select individual events&amp;rdquo;: 自定义选择事件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;配置完成后，GitHub 会向指定的 URL 发送一个 ping 事件来测试连接。&lt;/p&gt;
&lt;h2 id=&#34;配置-hook-server&#34;&gt;配置 Hook server&lt;/h2&gt;
&lt;p&gt;上面配置完，会得到一个提示“Last delivery was not successful”，这是因为还没有配置 Hook server。接下来做这部分工作。&lt;/p&gt;
&lt;h3 id=&#34;配置-hook-server-的-url&#34;&gt;配置 Hook server 的 URL&lt;/h3&gt;
&lt;p&gt;要配置 webhook.bio-spring.top，需要在 Apache2 中添加一个虚拟主机配置。具体步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建虚拟主机配置文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-apache&#34;&gt;&amp;lt;VirtualHost *:443&amp;gt;
    # 设置服务器名称
    ServerName webhook.bio-spring.top
    ServerAlias webhook.bio-spring.top

    # 启用 SSL
    SSLEngine on
    SSLCertificateFile /etc/letsencrypt/live/webhook.bio-spring.top/fullchain.pem
    SSLCertificateKeyFile /etc/letsencrypt/live/webhook.bio-spring.top/privkey.pem

    # 设置日志路径
    ErrorLog ${APACHE_LOG_DIR}/webhook-error.log
    CustomLog ${APACHE_LOG_DIR}/webhook-access.log combined

    # 设置文档根目录
    DocumentRoot /var/www/html/webhook
&amp;lt;/VirtualHost&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重启 Apache 服务：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo a2ensite webhook.conf
sudo service apache2 restart
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;添加 DNS 解析&lt;/p&gt;
&lt;p&gt;在 DNS 解析中添加 webhook.bio-spring.top 的解析，指向阿里云服务器的公网 IP 地址。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置 https 证书&lt;/p&gt;
&lt;p&gt;在阿里云服务器上安装 certbot 并配置 https 证书。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;sudo apt install certbot
sudo certbot --apache -d webhook.bio-spring.top
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;配置-hook-server-的脚本&#34;&gt;配置 Hook Server 的脚本&lt;/h3&gt;
&lt;p&gt;在 Hook Server 的文档根目录下创建一个 &lt;code&gt;index.php&lt;/code&gt; 文件，内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php
// 配置
$secret = &amp;quot;your-secret-key&amp;quot;;
$log_file = &amp;quot;/var/log/webhook/deploy-php.log&amp;quot;;
$deploy_script = &amp;quot;/path/to/deploy-hook.sh&amp;quot;;

// 记录日志
function write_log($message) {
    global $log_file;
    $date = date(&#39;Y-m-d H:i:s&#39;);
    file_put_contents($log_file, &amp;quot;[$date] $message\n&amp;quot;, FILE_APPEND);
}

// 验证签名
function verify_signature($payload, $signature) {
    global $secret;
    $expected = &amp;quot;sha256=&amp;quot; . hash_hmac(&#39;sha256&#39;, $payload, $secret);
    return hash_equals($expected, $signature);
}

// 确保是POST请求
if ($_SERVER[&#39;REQUEST_METHOD&#39;] !== &#39;POST&#39;) {
    http_response_code(405);
    die(&#39;Method Not Allowed&#39;);
}

// 获取GitHub签名
$headers = getallheaders();
$signature = isset($headers[&#39;X-Hub-Signature-256&#39;]) ? $headers[&#39;X-Hub-Signature-256&#39;] : &#39;&#39;;

if (empty($signature)) {
    write_log(&amp;quot;Error: No signature provided&amp;quot;);
    http_response_code(403);
    die(&#39;No signature&#39;);
}

// 获取请求体
$payload = file_get_contents(&#39;php://input&#39;);

// 验证签名
if (!verify_signature($payload, $signature)) {
    write_log(&amp;quot;Error: Invalid signature&amp;quot;);
    http_response_code(403);
    die(&#39;Invalid signature&#39;);
}

// 解析payload
$data = json_decode($payload, true);

// 检查是否是push事件
if (isset($data[&#39;ref&#39;]) &amp;amp;&amp;amp; $data[&#39;ref&#39;] === &#39;refs/heads/master&#39;) {
    write_log(&amp;quot;Received push to master branch&amp;quot;);
    
    // 执行部署脚本
    $output = [];
    $return_var = 0;
    exec(&amp;quot;bash $deploy_script 2&amp;gt;&amp;amp;1&amp;quot;, $output, $return_var);
    
    // 记录执行结果
    $output_str = implode(&amp;quot;\n&amp;quot;, $output);
    write_log(&amp;quot;Deploy script output:\n$output_str&amp;quot;);
    
    if ($return_var === 0) {
        write_log(&amp;quot;Deploy completed successfully&amp;quot;);
        echo &amp;quot;Deploy successful&amp;quot;;
    } else {
        write_log(&amp;quot;Deploy failed with code $return_var&amp;quot;);
        http_response_code(500);
        echo &amp;quot;Deploy failed&amp;quot;;
    }
} else {
    write_log(&amp;quot;Ignored non-master push event&amp;quot;);
    echo &amp;quot;Ignored&amp;quot;;
}
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重启 Apache 服务器之后，访问 webhook.bio-spring.top 应该会返回 &amp;ldquo;Method Not Allowed&amp;rdquo;。&lt;/p&gt;
&lt;h3 id=&#34;配置-deploy-hooksh-脚本&#34;&gt;配置 deploy-hook.sh 脚本&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;#!/bin/bash

# 设置工作目录
SITE_DIR=&amp;quot;/var/www/html/bio-spring.top&amp;quot;
LOG_FILE=&amp;quot;/var/log/webhook/deploy-sh.log&amp;quot;
REPO_DIR=&amp;quot;/home/git/bio-spring&amp;quot;

# 如果日志文件不存在则创建
if [ ! -f &amp;quot;$LOG_FILE&amp;quot; ]; then
    mkdir -p &amp;quot;$(dirname &amp;quot;$LOG_FILE&amp;quot;)&amp;quot;
    touch &amp;quot;$LOG_FILE&amp;quot;
    chown www-data:www-data &amp;quot;$LOG_FILE&amp;quot;
    chmod 644 &amp;quot;$LOG_FILE&amp;quot;
fi


# 记录部署时间
echo &amp;quot;Deployment started at $(date)&amp;quot; &amp;gt;&amp;gt; $LOG_FILE

# 更新代码仓库
cd $REPO_DIR || exit
GIT_SSH_COMMAND=&#39;ssh -i /home/git/.ssh/id_rsa&#39; git pull origin master &amp;gt;&amp;gt; $LOG_FILE 2&amp;gt;&amp;amp;1
GIT_SSH_COMMAND=&#39;ssh -i /home/git/.ssh/id_rsa&#39; git submodule update --recursive &amp;gt;&amp;gt; $LOG_FILE 2&amp;gt;&amp;amp;1

# 安装 hugo
# wget https://github.com/gohugoio/hugo/releases/download/v0.136.5/hugo_0.136.5_linux-amd64.deb
# dpkg -i hugo_0.136.5_linux-amd64.deb

# 构建网站
Rscript -e &#39;blogdown::build_site(baseURL = &amp;quot;/&amp;quot;)&#39; &amp;gt;&amp;gt; $LOG_FILE 2&amp;gt;&amp;amp;1

# 同步到网站目录
rsync -av --delete public/ $SITE_DIR/ &amp;gt;&amp;gt; $LOG_FILE 2&amp;gt;&amp;amp;1

echo &amp;quot;Deployment completed at $(date)&amp;quot; &amp;gt;&amp;gt; $LOG_FILE
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;测试&#34;&gt;测试&lt;/h2&gt;
&lt;p&gt;在 GitHub 仓库中推送代码，应该会看到阿里云服务器上的网站自动更新。同时，GitHub Webhook 的日志中也会记录 delivery 信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：由于 GitHub Webhook 的超时时间为 10 s，如果超过 10 s 没有响应（脚本没有执行完毕），GitHub 的状态会显示为“time out”。这种情况可以通过异步执行脚本解决。或者也可以忽略。&lt;/p&gt;
&lt;h3 id=&#34;异步执行脚本&#34;&gt;异步执行脚本&lt;/h3&gt;
&lt;p&gt;在 PHP 中实现异步处理，可以使用 &lt;code&gt;exec()&lt;/code&gt; 或 &lt;code&gt;shell_exec()&lt;/code&gt; 命令来启动后台进程。通过在命令末尾添加 &lt;code&gt;&amp;amp;&lt;/code&gt; 符号，可以让该进程在后台运行，而不阻塞主进程。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;// 异步启动任务
exec(&amp;quot;bash /path/to/deploy-hook.sh &amp;amp;&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上代码会在后台执行 &lt;code&gt;deploy-hook.sh&lt;/code&gt;，避免输出内容影响主进程。&lt;/p&gt;

        </description>
      </item>
    
      <item>
        <title>部署网站到 gh-pages</title>
        <link>bio-spring/post/2023/12/24/blogdown-site-to-gh-pages/</link>
        <pubDate>Sun, 24 Dec 2023 00:00:00 +0000</pubDate>
        <author>gaoch</author>
        <guid>bio-spring/post/2023/12/24/blogdown-site-to-gh-pages/</guid>
        <description>
          &lt;h2 id=&#34;relurl-的用法&#34;&gt;relURL 的用法&lt;/h2&gt;
&lt;p&gt;参见：&lt;a href=&#34;https://gohugo.io/functions/urls/relurl/#input-begins-with-a-slash&#34;&gt;https://gohugo.io/functions/urls/relurl/#input-begins-with-a-slash&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在将 &lt;code&gt;blogdown&lt;/code&gt; 创建的静态网站部署到 GitHub Pages 时，确保在 &lt;code&gt;config.toml&lt;/code&gt; 或 &lt;code&gt;config.yaml&lt;/code&gt; 文件中设置了正确的 &lt;code&gt;baseURL&lt;/code&gt;。这是指向你的 GitHub Pages 网站的基本 URL。&lt;/p&gt;
&lt;p&gt;在配置文件中添加如下行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;baseURL = &amp;quot;https://&amp;lt;username&amp;gt;.github.io/&amp;lt;repository-name&amp;gt;/&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;确保将 &lt;code&gt;&amp;lt;username&amp;gt;&lt;/code&gt; 替换为你的 GitHub 用户名，&lt;code&gt;&amp;lt;repository-name&amp;gt;&lt;/code&gt; 替换为你的仓库名称。&lt;/p&gt;
&lt;p&gt;另外，请确保 &lt;code&gt;publishDir&lt;/code&gt;（默认是 &lt;code&gt;public&lt;/code&gt; 文件夹）的内容正确地推送到 &lt;code&gt;gh-pages&lt;/code&gt; 分支。你可以使用如下命令将内容推送到 &lt;code&gt;gh-pages&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git subtree push --prefix public origin gh-pages
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个命令会将 &lt;code&gt;public&lt;/code&gt; 文件夹的内容推送到 &lt;code&gt;gh-pages&lt;/code&gt; 分支。确保在推送之前已经生成了静态网站，可以通过以下命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;blogdown::build_site()
&lt;/code&gt;&lt;/pre&gt;

        </description>
      </item>
    
      <item>
        <title>Git 添加多个 remote</title>
        <link>bio-spring/post/2023/09/13/git-add-multiple-remotes/</link>
        <pubDate>Wed, 13 Sep 2023 00:00:00 +0000</pubDate>
        <author>gaoch</author>
        <guid>bio-spring/post/2023/09/13/git-add-multiple-remotes/</guid>
        <description>
          &lt;p&gt;在 Git 中设置，从一个源 pull，向多个源 push，实现修改后一键 push 到多个服务器（如 GitHub + Gitee）。&lt;/p&gt;
&lt;p&gt;将 GitHub 作为主源，本地修改同时 push 到 GitHub 和 Gitee。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git remote add origin git@github.com:user/repository.git
git remote set-url --add --push origin git@github.com:user/repository.git
git remote set-url --add --push origin git@gitee.com:user/repository.git
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看配置结果。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git remote show origin
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;删掉无用的源&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;git remote set-url --delete --push origin git@gitee.com:user/repository.git
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实在不行，还可以直接修改 &lt;code&gt;.git/config&lt;/code&gt; 文件。&lt;/p&gt;

        </description>
      </item>
    
      <item>
        <title>Git 和 GitHub 使用指北</title>
        <link>bio-spring/post/2019/09/29/git-github-tutorial/</link>
        <pubDate>Sun, 29 Sep 2019 00:00:00 +0000</pubDate>
        <author>gaoch</author>
        <guid>bio-spring/post/2019/09/29/git-github-tutorial/</guid>
        <description>
          &lt;p&gt;今天&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=Mzg3NTA1MTM0NQ==&amp;amp;mid=100000025&amp;amp;idx=1&amp;amp;sn=f060e32833de25870a2a29a47870b643&amp;amp;chksm=4ec6212779b1a8312d1cb4f27823477e3168473ae4058cb89f1e3a6e96793f002e655b6a7407&amp;amp;scene=18&amp;amp;key=5b7091b0813876942fc85075a8cc8f984e6d4d87ecd805316b742ba8b7794eb227a20a153ace81fd88748619448f3068bd5e2e38cc501ad515cb9e6b4bfe1be54018f8e337780e22607fdb65e336bb4d&amp;amp;ascene=1&amp;amp;uin=NDI5ODQ5OTc1&amp;amp;devicetype=Windows+10&amp;amp;version=62060833&amp;amp;lang=zh_CN&amp;amp;pass_ticket=ETbgcY5wOJmK6csItr5E373xuGaeAaR3QUgLT8wGyYhEjdGAp%2FMxQxWTejbUuRqX&#34;&gt;小丫画图&lt;/a&gt;群里在讨论 GitHub 的使用。大家都说GitHub的使用挺简单的，我觉得也是。但是，要找一个比较系统的介绍的话，我还真没找到。所以，说说自己的使用经历吧。&lt;strong&gt;这些都是干货。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我对 GitHub 的使用时间不长，但是觉得真是个好东西。总的来说，特别适合于存放&lt;strong&gt;文本文件&lt;/strong&gt;，例如代码，markdown写成的文档，rmarkdown写成的书等。&lt;/p&gt;
&lt;p&gt;GitHub其实是支持Git版本控制软件的公共仓库，&lt;a href=&#34;#github-alternative&#34;&gt;类似的网站&lt;/a&gt;其实不止一个，但是GitHub是最流行的一个。&lt;/p&gt;
&lt;p&gt;所以，要想使用GitHub，你必须做的只有两件事：一、安装一个Git客户端&lt;a href=&#34;https://git-scm.com/downloads&#34;&gt;点击下载&lt;/a&gt;。二、在GitHub注册一个账号&lt;a href=&#34;https://github.com&#34;&gt;点击注册&lt;/a&gt;。这两步操作按住不提。&lt;/p&gt;
&lt;h1 id=&#34;使用-git&#34;&gt;使用 Git&lt;/h1&gt;
&lt;p&gt;在Windows下面，安装完Git客户端之后，鼠标右键菜单中会多出来两个命令：“Git GUI here”和“Git Bash here”。前者打开一个图形界面，后者打开一个终端。使用这两个传送门便可以进入Git的世界。&lt;/p&gt;
&lt;p&gt;如果当前的目录是一个Git目录，则自动会被Git识别出来。否则，你可以选择“新建一个”或者“克隆”一个。&lt;/p&gt;
&lt;h2 id=&#34;git-常用操作&#34;&gt;Git 常用操作&lt;/h2&gt;
&lt;p&gt;Git常用的命令有下面几个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git init sample&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在当前目录新建一个“sample”目录，在目录中启用Git版本控制系统。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git clone https://github.com/GuangchuangYu/course_bioinfo_training.git&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从GitHub克隆一个软件源到当前目录。这将在当前目录新建一个“course_bioinfo_training”文件夹，其中包含所有文件和版本历史。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git status&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;显示当前Git仓库的状态。如果有修改，新建，删除等操作，将会自动列举出来。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git add newfile.R&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;newfile.R 是一个新建的文件，其中我写了一些代码。要使用Git纪录版本历史，必须将其添加进来。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git commit&lt;/code&gt; 或者 &lt;code&gt;git commit -a&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个命令将生成一次操作，系统会打开默认的文本编辑器，让你写一下操作的主要内容。&lt;/p&gt;
&lt;h1 id=&#34;github-的使用&#34;&gt;GitHub 的使用&lt;/h1&gt;
&lt;p&gt;GitHub 事实上提供了一个远程 Git 仓库。这个远程仓库与本地仓库是关联在一起的，但有相互独立。在上面，我们已经使用过了 &lt;code&gt;git pull&lt;/code&gt; 命令，这个命令就是从远程向本地输送。与之对应，&lt;code&gt;git push&lt;/code&gt; 是本地向远程服务器传输，将本地的修改记录在服务器中。&lt;/p&gt;
&lt;p&gt;在 push 的过程中，需要验证身份，因此，我们需要配置认证信息。&lt;/p&gt;
&lt;h2 id=&#34;github-配置-ssh-密钥&#34;&gt;GitHub 配置 SSH 密钥&lt;/h2&gt;
&lt;p&gt;SSH 密钥是成对的，包括公钥和私钥，公钥登记到 GitHub 网站，私钥存储在本地计算机（私有）。&lt;/p&gt;
&lt;p&gt;密钥在本地生成。点击鼠标右键，选择“Git Bash here”，输入下列命令将生成一对SSH密钥。
默认情况下，私钥保存在 “&lt;code&gt;~/.ssh/id_rsa&lt;/code&gt;” 文件中，公钥保存在 “&lt;code&gt;~/.ssh/id_rsa.pub&lt;/code&gt;&amp;ldquo;文件中
（没错，在Windows下的Git bash下面也可以使用~代表家目录）。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ssh-keygen
cat ./.ssh/id_rsa.pub
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;复制这个公钥的全部内容，进入GitHub-Setting-SSH and GPG keys，选择“New SSH key”，将公钥粘贴进去，点击“Add SSH key”，即可完成公钥添加。&lt;/p&gt;
&lt;p&gt;这样，以后就调用 “Git bash shell” 时，便会自动提供私钥认证，不需要输入用户名和密码了。&lt;/p&gt;
&lt;h2 id=&#34;在-github-上创建一个-repository&#34;&gt;在 GitHub 上创建一个 repository&lt;/h2&gt;
&lt;p&gt;点击GitHub右上角的“+”，选择“Create a new repository”，按照提示操作即可。也就是在今年，GitHub上针对于免费用户才刚刚开放了“Private”的选项，如果有保密代码（暂时）不公开的，可以选择该选项。&lt;/p&gt;
&lt;p&gt;这步操作其实相当于在 GitHub 服务器上新建了一个目录。目录名称，也就是 Repository name。目录的路径就是 &lt;code&gt;username/repository_name&lt;/code&gt;。对应的网址（绝对路径）便是 &lt;code&gt;https://github.com/username/repository_name&lt;/code&gt;。对应的 Git 地址是 &lt;code&gt;git://git@github.com/username/repository_name.git&lt;/code&gt;。对应的 SSH 地址是&lt;code&gt;ssh://git@github.com/username/repository_name.git&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;创建一个本地仓库&#34;&gt;创建一个本地仓库&lt;/h2&gt;
&lt;p&gt;以我的 GitHub 上面创建的 “myfirstrepo” 为例，可以有两种方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;克隆一个&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;git clone  https://github.com/gaospecial/myfirstrepo.git
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;克隆自己的 repository，由于前面已经配置好了 SSH 认证，
所以可以直接 Push。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新建并配置一个&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;# 鼠标右键选择 &amp;quot;Git bash here&amp;quot;，进入 Git bash

# 在本地新建一个同名目录 myfirstrepo
mkdir myfirstrepo
cd myfirstrepo

# 配置远程 origin
git remote add origin https://github.com/gaospecial/myfirstrepo.git

# 更新文件
echo &amp;quot;# myfirstrepo&amp;quot; &amp;gt;&amp;gt; README.md
git add README.md
git commit -m &amp;quot;first commit&amp;quot;

git push -u origin master
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;新建的 repository 默认是没有 remote 链接的，所以需要使用 &lt;code&gt;git remote add&lt;/code&gt; 命令，
将远程的 &lt;code&gt;https://github.com/gaospecial/myfirstrepo.git&lt;/code&gt; 设置为 remote origin。
但要想 push 还需要进行至少一次 commit，这里是添加了一个 README.md 文件。&lt;/p&gt;
&lt;p&gt;顺便提一下，下面的命令与 remote url 的设置与变更有关。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git remote show

git remote show origin

git remote set-url origin https://github.com/gaospecial/myfirstrepo.git
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;我的-gitgithub-使用流程&#34;&gt;我的 Git/GitHub 使用流程&lt;/h1&gt;
&lt;p&gt;下面的操作，模拟了我完成一个小目标并将其记录在案的操作历史。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 用喜欢的方式进入本地 repository 目录
# 用喜欢的方式新建一个文件，xiaomubiao.R
# 用喜欢的文本编辑器打开 xiaomubiao.R
# 用喜欢的方式在 xiaomubiao.R 中敲了100行代码，完成了一个小目标
# 鼠标右键选择 &amp;quot;Git bash here&amp;quot;

# 查看状态，Git 自动发现了我的小目标
git status  

# 那我们把它添加进来
git add xiaomubiao.R

# 记录在案
git commit
# 在弹出的文本编辑器中，输入“完成了一个小目标”，保存并关闭文件

# 告诉大家我完成了一个小目标
git push

# 看看我完成了几个小目标了，
# 完成的小目标多了，有朝一日便可以变成大目标
git log
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;在-github-上使用-pull-request-贡献代码&#34;&gt;在 GitHub 上使用 Pull request 贡献代码&lt;/h1&gt;
&lt;p&gt;GitHub 相关的操作，上面提到的主要是三个“clone”，“pull”，“push”，可以被认为是“新建”，“更新（读）”和“更新（写）”三个操作。前两个操作不需要 SSH 权限，而“写操作”需要SSH权限。如果自己改正了别人repository 中的错误，那么则需要用 Pull request 来提请 repository 的管理员从我们这里 “更新” 一下。&lt;/p&gt;
&lt;p&gt;Pull request 需要在 GitHub 网站上操作。进入 repository 之后，有一个 Pull request 标签，里面有一个 “compare across forks” 链接，点击之后，GitHub 里面所有与该 repository 关联的 repository 都会显示出来。&lt;/p&gt;
&lt;p&gt;以 &lt;code&gt;GuangchuangYu/rvcheck&lt;/code&gt; 为例，我更新了其中的一些代码，想贡献出来。那么首先，我需要在这里 “Fork” 一个 “rvcheck” 到我自己那里，得到一个 &lt;code&gt;gaospecial/rvcheck&lt;/code&gt; 分枝。然后在自己的自留地里面随意修改，完成 commit 和 push 操作。&lt;/p&gt;
&lt;p&gt;这样，在点击 “compare across forks” 之后，我的 &lt;code&gt;gaospecial/rvcheck&lt;/code&gt; 便处于可选状态。这时候，选择 &lt;code&gt;base repository: GuanchuangYu/rvchek&lt;/code&gt;， &lt;code&gt;head repository: gaospecial/rvcheck&lt;/code&gt;，继续按提示操作即可创建一个 Pull request。&lt;/p&gt;
&lt;p&gt;作为 repository 的管理员，可以在 Pull request 下面看到别人提交的 Pull request 中的代码和说明，并通过回复进行交流。如果认为没问题，则可以选择 Merge Pull request，将Pull request 中的更改添加进来（执行了一次 git merge操作）。有些管理员还会联系你签一个版权协议（之前向 rstudio 提交 pull request 的时候遇到过。&lt;/p&gt;
&lt;h1 id=&#34;github-alternative&#34;&gt;GitHub 的替代品&lt;/h1&gt;
&lt;h2 id=&#34;可以替代-github-的代码托管服务&#34;&gt;可以替代 GitHub 的代码托管服务&lt;/h2&gt;
&lt;p&gt;以腾讯云为例：&lt;/p&gt;
&lt;p&gt;腾讯云开发平台的优势是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;国内访问快，不会被墙&lt;/li&gt;
&lt;li&gt;用户名好起（毕竟用户少嘛）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于已有的Git项目，可以通过下列途径关联。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 首先在服务器控制面板创建一个同名项目
# 参考这里：https://dev.tencent.com/help/git-import-tencentcloud

# 事实上，不用那么麻烦，用什么学过的几条命令就可以解决
git remote rm origin
git remote add origin https://git.dev.tencent.com/gaoch/myproject.git
git push --set-upstream origin master
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后我发现了腾讯云开发平台代码托管服务的缺点是：&lt;strong&gt;URL太长了&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;自建-git-服务器&#34;&gt;自建 Git 服务器&lt;/h2&gt;
&lt;p&gt;只要能够进行 SSH 操作的远程服务器，理论上都可以作为自建 Git 服务器。&lt;/p&gt;
&lt;p&gt;可以是阿里云这样的主机服务商，也可以是你能访问的任意一台Linux主机。&lt;/p&gt;
&lt;p&gt;具体的内容参见我以前写的一个帖子：&lt;a href=&#34;bio-spring/2018/12/29/private-git-server/&#34;&gt;设置私有Git服务器&lt;/a&gt;。&lt;/p&gt;
&lt;h1 id=&#34;在-rstudio-中使用-gitgithub&#34;&gt;在 RStudio 中使用 Git/GitHub&lt;/h1&gt;
&lt;p&gt;RStudio 打开一个 R project 之后，如果发现启用了 Git，会多出来一个 Git 标签（默认在右上方）。但是，这个 Git 点击起来真的反应很慢，&lt;a href=&#34;bio-spring/2018/10/24/donot-use-the-git-gui-of-rstudio/&#34;&gt;不推荐初学者和电脑配置不高的人士使用&lt;/a&gt;。&lt;/p&gt;

        </description>
      </item>
    
  </channel>
</rss>
