<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>统计学 on BIO-SPRING</title>
    <link>bio-spring/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6/</link>
    <description>Recent content in 统计学 on BIO-SPRING</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 26 Nov 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="bio-spring/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6/" rel="self" type="application/rss+xml" />

    
      <item>
        <title>样本水平富集分析</title>
        <link>bio-spring/post/2025/11/26/sample-level-enrichment-analysis/</link>
        <pubDate>Wed, 26 Nov 2025 00:00:00 +0000</pubDate>
        <author>gaoch</author>
        <guid>bio-spring/post/2025/11/26/sample-level-enrichment-analysis/</guid>
        <description>
          &lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;样本水平富集分析 (Sample-Level Enrichment Analysis, SLEA)&lt;/strong&gt; 是一种用于分析转录组数据集中&lt;strong&gt;每个样本内基因模块（或称基因集，如通路）转录状态&lt;/strong&gt;的方法。 &lt;/p&gt;
&lt;h3 id=&#34;主要特点和工作原理&#34;&gt;主要特点和工作原理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;逐样本分析：&lt;/strong&gt; 与传统的基因集富集分析 (GSEA) 不同，传统的 GSEA 通常是比较两组样本（例如，疾病组与正常组）之间基因集的富集情况，而 SLEA 是对数据集中的&lt;strong&gt;每个独立样本&lt;/strong&gt;计算其特定基因集（例如，某个癌症通路）的富集得分。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;富集得分 (Enrichment Score)：&lt;/strong&gt; SLEA 通过比较基因模块中基因的表达均值（或中位数）与同一样本中随机抽取的同等大小的基因集表达均值的分布，计算出一个 z-score 富集得分。这个得分反映了该基因模块在该样本中的活跃状态（上调或下调）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;无需预先分组：&lt;/strong&gt; 进行 SLEA 时，不需要预先知道样本的表型信息或临床分组，它可以直接从基因表达数据和基因集列表开始分析。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;可视化：&lt;/strong&gt; 结果通常以&lt;strong&gt;交互式热图&lt;/strong&gt;的形式呈现，其中行代表不同的基因模块，列代表各个样本，每个单元格显示该模块在该样本中的富集得分。这种可视化方式有助于直观地解释和识别富集模式。 &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;应用场景&#34;&gt;应用场景&lt;/h3&gt;
&lt;p&gt;SLEA 在生物医学研究中具有广泛的应用，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;识别肿瘤亚型：&lt;/strong&gt; 根据不同基因模块的富集模式对肿瘤样本进行聚类，从而发现新的分子亚型。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;关联分子特征与临床特征：&lt;/strong&gt; 将富集得分与患者的临床数据（例如，生存时间、治疗反应、临床分期）相关联，以发现与特定通路活跃度相关的预后标志物。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;研究模块之间的关系：&lt;/strong&gt; 探索不同信号通路或基因集在样本水平上的协同作用或拮抗关系。 &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;简而言之，SLEA 是一种强大的工具，能够深入挖掘单个样本的生物学特性，有助于理解疾病的异质性并发现潜在的治疗靶点。&lt;/p&gt;
&lt;p&gt;在微生物研究领域，样本水平富集分析 (SLEA) 的应用与在人类转录组研究中的应用有相似之处，但主要集中在通过分析&lt;strong&gt;微生物基因表达&lt;/strong&gt;或&lt;strong&gt;微生物群落的功能潜力&lt;/strong&gt;来理解复杂的生物学过程。&lt;/p&gt;
&lt;h2 id=&#34;在微生物研究中的应用&#34;&gt;在微生物研究中的应用&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;分析特定微生物的功能状态&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;理解细菌适应性：&lt;/strong&gt; 微生物基因表达的调控对于细菌在不断变化的环境条件（如肠道内的营养物质变化、宿主免疫反应）中生存和适应至关重要。SLEA 可以用于分析特定微生物在不同条件下哪些功能通路（例如，铁螯合、鞭毛合成、抗生素抗性）被激活或抑制。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;宿主-病原体相互作用：&lt;/strong&gt; 在研究宿主细胞与病原体（如幽门螺杆菌 &lt;em&gt;H. pylori&lt;/em&gt; 或结核分枝杆菌 &lt;em&gt;M. tuberculosis&lt;/em&gt;）的相互作用时，SLEA 可用于鉴定细菌在细胞内感染期间快速适应的基因表达特征，例如与宿主粘附或营养获取相关的基因集。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;整合宏基因组/宏转录组数据：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在分析复杂的微生物群落（如肠道微生物组）时，研究人员通常会生成宏基因组（DNA序列）或宏转录组（RNA序列）数据。这些数据包含了群落中所有成员的基因信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过将这些宏组学数据映射到已知的微生物基因集文库（例如，KEGG 通路、功能基因簇），SLEA 可以评估&lt;strong&gt;每个样本&lt;/strong&gt;中特定代谢或功能通路的整体活跃水平，而不仅仅是关注单个物种的丰度。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;识别与疾病或环境因素相关的微生物功能模式：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;研究人员可以利用 SLEA 识别与特定临床特征（如炎症性肠病 IBD、肥胖、抗生素治疗反应）相关的微生物功能特征。例如，通过微生物集富集分析 (Microbe-set Enrichment Analysis, MSEA) 可以根据文献记录的微生物与哺乳动物基因的关联，将微生物分组，并找出与宿主表型相关的富集模式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在环境微生物学研究中，SLEA 可用于评估不同环境条件下（如盐度变化、污染物存在）微生物群落的功能潜力，例如氮循环、硫代谢等通路的活跃度。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;结合单细胞技术：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新兴的微生物单细胞测序技术可以提供更高分辨率的个体细胞功能信息。将这些技术与 SLEA 相结合，有助于确定在复杂的群落中哪些特定的细菌细胞正在利用宿主衍生的化合物或表现出特定的基因表达变化。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;SLEA 在微生物研究中的应用核心在于将高通量测序数据转化为可解释的、样本特异性的&lt;strong&gt;功能洞见&lt;/strong&gt;，帮助研究人员从“有哪些微生物”深入到“这些微生物在做什么”以及“它们的功能活性如何影响宿主或环境”。&lt;/p&gt;
&lt;h2 id=&#34;r-语言示例&#34;&gt;R 语言示例&lt;/h2&gt;
&lt;p&gt;下面是一个用 &lt;strong&gt;R 语言&lt;/strong&gt; 实现 SLEA（样本水平富集分析）的示例。&lt;/p&gt;
&lt;p&gt;我们将使用一个流行的方法，即 &lt;strong&gt;ssGSEA&lt;/strong&gt;（单样本 GSEA），这是 SLEA 的一个具体实现，通过 &lt;strong&gt;GSVA&lt;/strong&gt; (Gene Set Variation Analysis) R 包来实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;先决条件：安装必要的 R 包&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你需要安装 &lt;code&gt;GSVA&lt;/code&gt; 包以及一个用于处理示例数据的包（如 &lt;code&gt;limma&lt;/code&gt; 或 &lt;code&gt;GSEABase&lt;/code&gt;）。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;if (!requireNamespace(&amp;quot;BiocManager&amp;quot;, quietly = TRUE))
    install.packages(&amp;quot;BiocManager&amp;quot;)

BiocManager::install(&amp;quot;GSVA&amp;quot;)
BiocManager::install(&amp;quot;GSEABase&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;R 语言实现示例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个示例分为三个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;准备数据：&lt;/strong&gt; 获取一个基因表达矩阵和一些基因集（通路）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;运行 GSVA：&lt;/strong&gt; 使用 &lt;code&gt;gsva()&lt;/code&gt; 函数计算每个样本的富集得分。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;可视化结果：&lt;/strong&gt; 使用热图展示富集得分。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# 1. 加载必要的库
library(GSVA)
library(GSEABase)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Loading required package: BiocGenerics
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Loading required package: generics
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Attaching package: &#39;generics&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## The following objects are masked from &#39;package:base&#39;:
## 
##     as.difftime, as.factor, as.ordered, intersect, is.element, setdiff,
##     setequal, union
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Attaching package: &#39;BiocGenerics&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## The following objects are masked from &#39;package:stats&#39;:
## 
##     IQR, mad, sd, var, xtabs
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## The following objects are masked from &#39;package:base&#39;:
## 
##     anyDuplicated, aperm, append, as.data.frame, basename, cbind,
##     colnames, dirname, do.call, duplicated, eval, evalq, Filter, Find,
##     get, grep, grepl, is.unsorted, lapply, Map, mapply, match, mget,
##     order, paste, pmax, pmax.int, pmin, pmin.int, Position, rank,
##     rbind, Reduce, rownames, sapply, saveRDS, table, tapply, unique,
##     unsplit, which.max, which.min
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Loading required package: Biobase
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Welcome to Bioconductor
## 
##     Vignettes contain introductory material; view with
##     &#39;browseVignettes()&#39;. To cite Bioconductor, see
##     &#39;citation(&amp;quot;Biobase&amp;quot;)&#39;, and for packages &#39;citation(&amp;quot;pkgname&amp;quot;)&#39;.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Loading required package: annotate
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Loading required package: AnnotationDbi
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Loading required package: stats4
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Loading required package: IRanges
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Loading required package: S4Vectors
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Attaching package: &#39;S4Vectors&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## The following object is masked from &#39;package:utils&#39;:
## 
##     findMatches
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## The following objects are masked from &#39;package:base&#39;:
## 
##     expand.grid, I, unname
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Loading required package: XML
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Loading required package: graph
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Attaching package: &#39;graph&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## The following object is masked from &#39;package:XML&#39;:
## 
##     addNode
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(pheatmap) # 用于绘制热图

# --- 2. 准备数据 ---

# A. 准备一个示例的基因表达矩阵 (Exprs Matrix)
# 实际工作中，这是你自己的 RNA-seq 或芯片数据
# 行是基因，列是样本
# 为了演示，我们创建一个包含1000个基因和10个样本的随机数据
set.seed(123)
nr_genes &amp;lt;- 1000
nr_samples &amp;lt;- 10
expr_data &amp;lt;- matrix(rnorm(nr_genes * nr_samples), nrow = nr_genes)
rownames(expr_data) &amp;lt;- paste0(&amp;quot;gene_&amp;quot;, 1:nr_genes)
colnames(expr_data) &amp;lt;- paste0(&amp;quot;sample_&amp;quot;, 1:nr_samples)

# 对数据进行标准化（ssGSEA通常推荐使用非标准化数据，但我们这里简单起见使用Z-score模拟）
# 实际应用中，确保你的数据是适当的 count 或 logCPM/VST 格式
# expr_data &amp;lt;- apply(expr_data, 2, function(x) (x - mean(x)) / sd(x)) # 可以选择z-score标准化

# B. 准备一个基因集列表 (Gene Sets)
# 这通常是你从 MSigDB 或 KEGG 数据库下载的 GMT 文件
# 我们手动创建几个小的基因集用于演示
gene_sets &amp;lt;- list(
  &amp;quot;Pathway_A&amp;quot; = paste0(&amp;quot;gene_&amp;quot;, sample(1:nr_genes, 30)), # 包含30个基因
  &amp;quot;Pathway_B&amp;quot; = paste0(&amp;quot;gene_&amp;quot;, sample(1:nr_genes, 25)), # 包含25个基因
  &amp;quot;Pathway_C&amp;quot; = paste0(&amp;quot;gene_&amp;quot;, sample(1:nr_genes, 50))  # 包含50个基因
)

# 将列表转换为 GSEABase 要求的 GeneSetCollection 格式
gene_sets_collection &amp;lt;- GeneSetCollection(lapply(names(gene_sets), function(name) {
  GeneSet(gene_sets[[name]], setName = name)
}))


# --- 3. 运行 SLEA (使用 GSVA 的 ssGSEA 方法) ---

# 使用 gsva() 函数进行计算
# method=&amp;quot;ssGSEA&amp;quot; 指定使用单样本富集分析方法 (即 SLEA 的一种实现)
ssparam = ssgseaParam(
  exprData = expr_data,
  geneSets = gene_sets_collection
)
slea_scores &amp;lt;- gsva(ssparam)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## ℹ GSVA version 2.4.1
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## ℹ Searching for genes/features with constant values
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## ℹ Calculating  ssGSEA scores for 3 gene sets
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## ℹ Calculating ranks
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## ℹ Calculating rank weights
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## ℹ Normalizing ssGSEA scores
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## ✔ Calculations finished
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# slea_scores 是一个新的矩阵，行是基因集，列是样本，值为富集得分

print(&amp;quot;SLEA 富集得分矩阵的前几行和列:&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;SLEA 富集得分矩阵的前几行和列:&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;print(round(slea_scores[, 1:4], 3))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##           sample_1 sample_2 sample_3 sample_4
## Pathway_A    0.487    0.529    0.063    0.032
## Pathway_B    0.356    0.563    0.496    1.028
## Pathway_C    0.274    0.294    0.652    0.605
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# --- 4. 可视化结果 (交互式热图) ---

# 将富集得分矩阵可视化为热图，这是 SLEA 结果最常见的展示方式
pheatmap(
  slea_scores,
  cluster_rows = TRUE,    # 对通路进行聚类
  cluster_cols = TRUE,    # 对样本进行聚类（有助于发现亚型）
  show_colnames = TRUE,
  show_rownames = TRUE,
  main = &amp;quot;SLEA/ssGSEA Enrichment Scrore Heatmap&amp;quot;
)
&lt;/code&gt;&lt;/pre&gt;
&lt;img src=&#34;bio-spring/post/2025/11/26/sample-level-enrichment-analysis/index.zh_files/figure-html/unnamed-chunk-1-1.png&#34; width=&#34;672&#34; /&gt;
&lt;p&gt;&lt;strong&gt;结果解释&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;运行上述代码后，你会得到一个名为 &lt;code&gt;slea_scores&lt;/code&gt; 的矩阵，其中包含了每个基因集在每个样本中的富集得分（通常在 -1 到 1 之间）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;正值：&lt;/strong&gt; 表示该基因集中的基因在该样本中整体倾向于高表达（通路活跃）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;负值：&lt;/strong&gt; 表示该基因集中的基因在该样本中整体倾向于低表达（通路抑制）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;同时，R 会弹出一个热图窗口，直观地展示哪些通路在哪些样本中活跃，并且通过聚类，你可以清晰地看到样本是否自然形成了不同的亚群（正如你描述的应用场景：识别肿瘤亚型）。&lt;/p&gt;
&lt;h2 id=&#34;关于-gsva-软件包&#34;&gt;关于 GSVA 软件包&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;GSVA&lt;/code&gt; &lt;strong&gt;是一个功能强大的 R 语言软件包，实现了基因集变异分析 (Gene Set Variation Analysis) 方法&lt;/strong&gt;。它是进行样本水平富集分析 (SLEA) 的核心工具，广泛应用于转录组学数据的分析中。&lt;/p&gt;
&lt;h3 id=&#34;核心功能与特点&#34;&gt;核心功能与特点&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;GSVA&lt;/code&gt; 软件包的主要目标是将传统的“基因中心”分析转化为“通路（基因集）中心”分析。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;单样本分析：&lt;/strong&gt; 与需要比较两组样本的传统 GSEA 不同，&lt;code&gt;GSVA&lt;/code&gt; 能够估计&lt;strong&gt;每个单独样本&lt;/strong&gt;中预定义基因集（如信号通路、功能模块、免疫特征）的富集得分或活跃度。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数据转换：&lt;/strong&gt; 它将输入的“基因 × 样本”表达矩阵转换为“基因集 × 样本”的富集得分矩阵。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;无监督与非参数：&lt;/strong&gt; &lt;code&gt;GSVA&lt;/code&gt; 是一种非参数、无监督的方法，意味着它不需要预先知道样本的分组信息（如疾病 vs. 正常），使得分析更加灵活，尤其适用于高度异质性的数据集。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;支持多种方法：&lt;/strong&gt; &lt;code&gt;GSVA&lt;/code&gt; 软件包不仅实现了其同名方法 GSVA，还集成了其他三种流行的单样本富集分析方法：&lt;strong&gt;ssGSEA&lt;/strong&gt;、&lt;strong&gt;z-score&lt;/strong&gt; 和 &lt;strong&gt;PLAGE&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;适用性广：&lt;/strong&gt; 它可以处理来自微阵列 (microarray) 和 RNA-seq 的基因表达数据，也可应用于其他分子谱数据，如miRNA表达、拷贝数变异 (CNV) 等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;主要应用场景&#34;&gt;主要应用场景&lt;/h3&gt;
&lt;p&gt;通过 &lt;code&gt;GSVA&lt;/code&gt; 生成的富集得分矩阵，用户可以进行一系列下游分析，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;样本聚类：&lt;/strong&gt; 根据通路活跃度对样本进行聚类，有助于发现新的疾病亚型（如肿瘤亚型）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;差异通路分析：&lt;/strong&gt; 比较不同临床组别（如治疗前后）之间的通路活跃度差异。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;生存分析：&lt;/strong&gt; 将通路富集得分与患者生存期关联，识别预后相关的通路。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;相关性分析：&lt;/strong&gt; 研究不同通路之间的协同作用或拮抗关系。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;四种算法&#34;&gt;四种算法&lt;/h3&gt;
&lt;p&gt;这四种算法（GSVA、ssGSEA、PLAGE、Z-score）都旨在实现样本水平富集分析（SLEA），即为每个样本计算通路活跃度得分，但它们在数学原理、标准化方法和具体实现细节上存在显著差异。&lt;/p&gt;
&lt;p&gt;以下是它们的主要区别：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;&lt;strong&gt;特性&lt;/strong&gt;&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;&lt;strong&gt;GSVA (Hänzelmann et al., 2013)&lt;/strong&gt;&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;&lt;strong&gt;ssGSEA (Barbie et al., 2009)&lt;/strong&gt;&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;&lt;strong&gt;PLAGE (Tomfohr et al., 2005)&lt;/strong&gt;&lt;/th&gt;
          &lt;th style=&#34;text-align: left&#34;&gt;&lt;strong&gt;Z-score (Lee et al., 2008)&lt;/strong&gt;&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;方法类型&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;基于核密度估计 (KDE)&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;基于等级排序 (Rank-based)&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;基于奇异值分解 (SVD)&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;基于标准分数 (Z-score)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;内部标准化&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;无&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;有&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;有（行/基因维度）&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;有（行/基因维度）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;跨样本可比性&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;得分相对分布可比&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;标准化后可比&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;得分独立，可比&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;得分独立，可比&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;&lt;strong&gt;速度&lt;/strong&gt;&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;较快&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;较慢&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;较快&lt;/td&gt;
          &lt;td style=&#34;text-align: left&#34;&gt;较快&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;详细区别解释&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. GSVA (Gene Set Variation Analysis)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;原理：&lt;/strong&gt; GSVA 使用&lt;strong&gt;非参数核密度估计 (KDE)&lt;/strong&gt; 方法。它将基因表达值转换为一个排序统计量，然后根据基因集内部和外部的累积概率分布之间的差异来计算富集得分。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;特点：&lt;/strong&gt; 它不需要对数据进行跨样本的标准化。GSVA 算法特别适用于处理微阵列和 RNA-seq 数据，其得分的分布通常可以提供较好的跨样本比较。它是 &lt;code&gt;GSVA&lt;/code&gt; 软件包的默认方法。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;2. ssGSEA (single sample GSEA)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;原理：&lt;/strong&gt; ssGSEA 源自传统的 GSEA 方法，但将其应用于单个样本。它计算样本内所有基因的表达值排名，然后评估目标基因集中的基因是倾向于排在前面还是后面，通过累积和统计量来计算得分。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;特点：&lt;/strong&gt; ssGSEA 的计算相对较慢，因为它需要对每个样本单独排序。它通常会进行额外的标准化步骤（例如将得分范围缩放到 -1 到 1 之间），以确保跨样本的可比性。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;3. PLAGE (Pathway Level Analysis of Gene Expression)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;原理：&lt;/strong&gt; PLAGE 基于&lt;strong&gt;奇异值分解 (SVD)&lt;/strong&gt;。它将基因集看作一个“特征向量”，计算每个样本在这个特征向量上的投影分数。可以理解为寻找基因集的主要表达模式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;特点：&lt;/strong&gt; PLAGE 要求输入数据在**行维度（基因维度）**进行标准化（例如 z-score 标准化）。它的计算速度非常快，结果稳定，对样本数量不太敏感。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;4. Z-score (Combined Z-score)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;原理：&lt;/strong&gt; 这是最简单直观的方法。它要求输入数据在**行维度（基因维度）**进行 z-score 标准化。然后，对于一个特定的基因集，它计算该样本中所有属于该基因集的基因的 z-score 均值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;特点：&lt;/strong&gt; 计算速度快。由于基于平均值，它对离群值（Outliers）比较敏感。与 PLAGE 类似，它依赖于预先对所有基因表达值进行跨样本标准化。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;总结与选择建议&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果你希望使用一个&lt;strong&gt;默认、稳健且不需要复杂数据预处理&lt;/strong&gt;的方法，&lt;strong&gt;GSVA&lt;/strong&gt; 或 &lt;strong&gt;ssGSEA&lt;/strong&gt; 是很好的选择。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果你追求&lt;strong&gt;极快的速度&lt;/strong&gt;并且可以接受对&lt;strong&gt;基因进行预标准化&lt;/strong&gt;，&lt;strong&gt;PLAGE&lt;/strong&gt; 和 &lt;strong&gt;Z-score&lt;/strong&gt; 是更快的替代方案。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在微生物研究或人类转录组研究中，这些算法的选择通常取决于研究人员的偏好和对数据特征的理解，它们通常都能提供一致的生物学见解。&lt;/p&gt;
&lt;h3 id=&#34;算法的区别&#34;&gt;算法的区别&lt;/h3&gt;
&lt;p&gt;要比较四种 SLEA 算法（GSVA、ssGSEA、PLAGE、Z-score）的结果差异，最好的方法是在同一份表达谱数据和同一组基因集上运行它们，然后比较它们生成的富集得分矩阵的相关性，并通过可视化手段直观展示。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(corrplot)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## corrplot 0.95 loaded
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# --- 3. 运行四种 GSVA 算法 ---

# A. GSVA 方法
# 使用 gsvaParam 构造函数定义参数对象
gsva_param &amp;lt;- gsvaParam(expr_data, gene_sets_collection)
scores_gsva &amp;lt;- gsva(gsva_param, verbose = FALSE)

# B. ssGSEA 方法
# 使用 ssgseaParam 构造函数定义参数对象
ssgsea_param &amp;lt;- ssgseaParam(expr_data, gene_sets_collection) 
# 默认 ssgsea.norm = TRUE，将分数标准化到 -1 到 1 之间
scores_ssgsea &amp;lt;- gsva(ssgsea_param, verbose = FALSE)

# C. PLAGE 方法
# 使用 plageParam 构造函数定义参数对象
plage_param &amp;lt;- plageParam(expr_data, gene_sets_collection)
scores_plage &amp;lt;- gsva(plage_param, verbose = FALSE)

# D. Z-score 方法
# 使用 zscoreParam 构造函数定义参数对象
zscore_param &amp;lt;- zscoreParam(expr_data, gene_sets_collection)
scores_zscore &amp;lt;- gsva(zscore_param, verbose = FALSE)


# --- 4. 结果比较与可视化 ---

# 将所有结果合并到一个数据框（或矩阵）中，以便于比较相关性
# 注意：不同方法的得分尺度不同，直接比较数值意义不大，主要看相对排序或相关性。
# 我们重点关注每种方法在所有样本中对特定通路的得分模式。

# 提取 Pathway_A 的得分，并合并到一个矩阵中
comparison_matrix &amp;lt;- rbind(
  &amp;quot;GSVA&amp;quot; = scores_gsva[&amp;quot;Pathway_A&amp;quot;, ],
  &amp;quot;ssGSEA&amp;quot; = scores_ssgsea[&amp;quot;Pathway_A&amp;quot;, ],
  &amp;quot;PLAGE&amp;quot; = scores_plage[&amp;quot;Pathway_A&amp;quot;, ],
  &amp;quot;Z-score&amp;quot; = scores_zscore[&amp;quot;Pathway_A&amp;quot;, ]
)
colnames(comparison_matrix) &amp;lt;- colnames(expr_data)

print(&amp;quot;Pathway_A 在四种方法下的得分矩阵:&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;Pathway_A 在四种方法下的得分矩阵:&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;print(round(comparison_matrix, 3))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##         sample_1 sample_2 sample_3 sample_4 sample_5 sample_6 sample_7 sample_8
## GSVA       0.043    0.205   -0.163   -0.246   -0.234   -0.072    0.025   -0.029
## ssGSEA     0.487    0.529    0.063    0.032    0.028    0.217    0.404    0.271
## PLAGE     -0.499   -0.213    0.309    0.092   -0.293   -0.248    0.463    0.259
## Z-score    0.337    1.185   -0.799   -1.213   -1.200   -0.062    0.047   -0.042
##         sample_9 sample_10
## GSVA       0.242     0.236
## ssGSEA     0.448     0.416
## PLAGE      0.352    -0.222
## Z-score    1.105     0.642
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# 可视化比较：使用热图展示不同方法在不同样本间的得分差异
pheatmap(
  comparison_matrix,
  cluster_rows = FALSE, # 不对方法聚类
  cluster_cols = TRUE,  # 对样本聚类
  main = &amp;quot;Differences of four GSVA when applied to Pathway_A&amp;quot;,
  scale = &amp;quot;row&amp;quot; # 按行（方法）进行标准化，使颜色具有可比性
)
&lt;/code&gt;&lt;/pre&gt;
&lt;img src=&#34;bio-spring/post/2025/11/26/sample-level-enrichment-analysis/index.zh_files/figure-html/unnamed-chunk-2-1.png&#34; width=&#34;672&#34; /&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# 可视化相关性：计算不同方法之间的 Spearman 相关系数
# Spearman 相关性更适合非正态分布的富集得分
correlation_matrix &amp;lt;- cor(t(comparison_matrix), method = &amp;quot;spearman&amp;quot;)

print(&amp;quot;四种方法之间的 Spearman 相关性矩阵:&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;四种方法之间的 Spearman 相关性矩阵:&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;print(round(correlation_matrix, 3))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##          GSVA ssGSEA PLAGE Z-score
## GSVA    1.000  0.891 0.139   0.964
## ssGSEA  0.891  1.000 0.018   0.952
## PLAGE   0.139  0.018 1.000   0.103
## Z-score 0.964  0.952 0.103   1.000
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# 使用 corrplot 进行可视化
corrplot(correlation_matrix, method = &amp;quot;circle&amp;quot;, type = &amp;quot;upper&amp;quot;, order = &amp;quot;hclust&amp;quot;,
         title = &amp;quot;GSVA Results Correlations&amp;quot;, mar=c(0,0,1,0))
&lt;/code&gt;&lt;/pre&gt;
&lt;img src=&#34;bio-spring/post/2025/11/26/sample-level-enrichment-analysis/index.zh_files/figure-html/unnamed-chunk-2-2.png&#34; width=&#34;672&#34; /&gt;

        </description>
      </item>
    
      <item>
        <title>GSEA原理及其在微生物组数据的广义化应用</title>
        <link>bio-spring/post/2025/11/21/gsea-in-microbiome-analysis/</link>
        <pubDate>Fri, 21 Nov 2025 00:00:00 +0000</pubDate>
        <author>gaoch</author>
        <guid>bio-spring/post/2025/11/21/gsea-in-microbiome-analysis/</guid>
        <description>
          &lt;h2 id=&#34;gsea分析的统计学核心原理&#34;&gt;GSEA分析的统计学核心原理&lt;/h2&gt;
&lt;p&gt;GSEA（Gene Set Enrichment Analysis，基因集富集分析）是一种基于阈值的计算方法，其核心统计学目标是判断一个预先定义的基因集（Gene Set）内的基因，是否在两个生物学状态（例如肿瘤组织 vs 正常组织）的基因表达排序列表中呈现非随机的排列。不同于传统的差异表达分析（只关注差异显著的少数基因），GSEA关注的是整个基因表达谱的整体趋势，利用加权柯尔莫哥洛夫-斯米尔诺夫（Kolmogorov-Smirnov）统计量来评估整体富集程度。&lt;/p&gt;
&lt;h3 id=&#34;基因排序与富集分数的计算&#34;&gt;基因排序与富集分数的计算&lt;/h3&gt;
&lt;p&gt;GSEA算法的第一步并非筛选基因，而是对所有检测到的基因进行全量排序，随后通过特定的“游走”算法计算富集分数。&lt;/p&gt;
&lt;h4 id=&#34;基因列表的预排序&#34;&gt;基因列表的预排序&lt;/h4&gt;
&lt;p&gt;分析首先需要建立一个排序的基因列表（Ranked Gene List）。根据基因表达量与表型（Phenotype）的相关性计算统计量（如Signal-to-Noise Ratio, t-test statistic, Pearson correlation等）。&lt;/p&gt;
&lt;p&gt;如果基因在实验组高表达，它会被排在列表的顶部；如果在对照组高表达，则排在列表底部；若无差异，则处于中间。这一步将生物学问题转化为了一个有序的数学序列。&lt;/p&gt;
&lt;h4 id=&#34;游走算法与ks统计量&#34;&gt;游走算法与KS统计量&lt;/h4&gt;
&lt;p&gt;这是GSEA的核心算法步骤。为了计算某个特定基因集（例如“细胞周期通路”）的富集分数（Enrichment Score, ES），算法会从上到下遍历上述的排序基因列表：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当遇到属于该基因集的基因时，累积统计量增加（加分）；&lt;/li&gt;
&lt;li&gt;当遇到不属于该基因集的基因时，累积统计量减少（减分）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;增加和减少的幅度与该基因与表型的相关性强度有关（加权）。富集分数（ES）就是这个随机游走过程中偏离零点的最大偏差值。如果基因集的成员主要集中在列表顶部，ES为正值；若集中在底部，ES为负值；若均匀分布，ES接近于零。这本质上是一种加权的Kolmogorov-Smirnov样统计量。&lt;/p&gt;
&lt;h3 id=&#34;显著性评估与多重假设检验&#34;&gt;显著性评估与多重假设检验&lt;/h3&gt;
&lt;p&gt;计算出ES值后，必须从统计学上判断该分数是否仅仅是由随机因素造成的，以及在同时检测成百上千个基因集时如何控制假阳性。&lt;/p&gt;
&lt;h4 id=&#34;置换检验建立零假设分布&#34;&gt;置换检验建立零假设分布&lt;/h4&gt;
&lt;p&gt;为了获得P值，GSEA采用置换检验（Permutation Test）。通常的做法是保持基因表达数据不变，随机打乱样本的表型标签（Phenotype Permutation）。&lt;/p&gt;
&lt;p&gt;通过上千次的随机打乱，重新计算该基因集在随机状态下的ES值，从而生成一个经验性的零假设分布（Null Distribution）。将实际观测到的ES值与这个零分布进行比较，计算出经验P值（Nominal P-value）。这种方法保留了基因之间复杂的共表达结构（Correlation structure），比简单的基因随机抽样更符合生物学实际。&lt;/p&gt;
&lt;h4 id=&#34;归一化富集分数&#34;&gt;归一化富集分数&lt;/h4&gt;
&lt;p&gt;由于不同的基因集包含的基因数量差异很大（有的含10个基因，有的含500个），较大的基因集往往更容易获得较大的ES绝对值。为了在不同基因集之间进行横向比较，必须消除基因集大小的影响。&lt;/p&gt;
&lt;p&gt;通过对ES进行标准化处理，得到归一化富集分数（Normalized Enrichment Score, NES）。NES是实际ES值除以同等大小基因集在零分布中的平均ES值计算得出的。NES是比较不同通路富集程度的主要指标。&lt;/p&gt;
&lt;h4 id=&#34;错误发现率&#34;&gt;错误发现率&lt;/h4&gt;
&lt;p&gt;在一次分析中通常会测试数千个基因集，多重假设检验会导致假阳性累积。GSEA不使用传统的Bonferroni校正（过于保守），而是采用错误发现率（False Discovery Rate, FDR）进行控制。&lt;/p&gt;
&lt;p&gt;通过计算q-value，估算在给定的NES阈值下，发现的显著基因集中可能有多少比例是假阳性。通常设定FDR &amp;lt; 0.25或&amp;lt; 0.05作为显著性的筛选标准，这比P值更具参考价值。&lt;/p&gt;
&lt;h3 id=&#34;核心富集基因的界定&#34;&gt;核心富集基因的界定&lt;/h3&gt;
&lt;p&gt;GSEA不仅给出评分，还能定位起关键作用的基因。&lt;/p&gt;
&lt;h4 id=&#34;前导边缘分析&#34;&gt;前导边缘分析&lt;/h4&gt;
&lt;p&gt;在得到显著富集的基因集后，研究者往往关心具体是哪些基因导致了这种富集。这部分基因被称为前导边缘子集（Leading Edge Subset）。&lt;/p&gt;
&lt;p&gt;对于正向富集的基因集，它是从列表顶部开始，直到ES达到最大值（峰值）出现之前的所有该基因集内的基因。这些基因是该通路在实验条件下发生变化的核心驱动因素，具有最高的生物学解释价值。&lt;/p&gt;
&lt;h2 id=&#34;基于秩次统计的广义化应用原理&#34;&gt;基于秩次统计的广义化应用原理&lt;/h2&gt;
&lt;p&gt;GSEA本质上不依赖于生物学背景，而是一种通用的非参数统计方法。其核心逻辑是检验“某个预定义的子集成员是否倾向于聚集在一个排序列表的顶部或底部”。只要数据满足“全量排序”和“类别标签”这两个条件，就可以应用这种“富集”分析的思想。&lt;/p&gt;
&lt;h3 id=&#34;数据映射与数学抽象&#34;&gt;数据映射与数学抽象&lt;/h3&gt;
&lt;p&gt;要将GSEA思想应用于非生物学数据，首先需要将通用数据映射到算法所需的两个核心输入要素上。&lt;/p&gt;
&lt;h4 id=&#34;排序列表的构建&#34;&gt;排序列表的构建&lt;/h4&gt;
&lt;p&gt;在生物学中，这是基因列表。在通用场景下，这可以是任何具有度量值的实体列表。你需要选择一个通过数值可以量化的指标（Metric）对所有实体进行排序。&lt;/p&gt;
&lt;p&gt;例如，在电商分析中，实体可以是“商品”，排序指标可以是“销售增长率”或“用户评分”；在人力资源分析中，实体可以是“员工”，排序指标可以是“绩效考核分数”。关键在于这个列表必须是有序的，且包含了所有关注的观测对象，而不仅仅是头部或尾部对象。&lt;/p&gt;
&lt;h4 id=&#34;类别的定义与集合映射&#34;&gt;类别的定义与集合映射&lt;/h4&gt;
&lt;p&gt;在生物学中，这是基因集（通路）。在通用场景下，这是具有共同属性的实体集合。&lt;/p&gt;
&lt;p&gt;继续上述例子，在电商中，类别可以是“品牌”、“产地”或“品类”（如电子产品、家居用品）；在人力资源中，类别可以是“部门”、“入职年份区间”或“学历背景”。如果我们要分析“某个品牌是否显著占据了高增长商品的行列”，这个品牌下的所有商品就构成了一个“集合（Set）”。&lt;/p&gt;
&lt;h3 id=&#34;统计检验的核心逻辑&#34;&gt;统计检验的核心逻辑&lt;/h3&gt;
&lt;p&gt;将数据映射后，评估类别对排序影响的过程，实际上就是验证该类别在序列分布上的非随机性。&lt;/p&gt;
&lt;h4 id=&#34;它是非参数检验的一种变体&#34;&gt;它是非参数检验的一种变体&lt;/h4&gt;
&lt;p&gt;GSEA所使用的加权Kolmogorov-Smirnov（KS）统计量，本质上是在比较两个累积分布函数。在通用数据中，零假设（Null Hypothesis）是：某个特定的类别（如品牌A）的成员，均匀且随机地散布在整个排序列表（如所有商品的销量排名）中。&lt;/p&gt;
&lt;p&gt;如果计算出的富集分数（ES）很高，且显著性检验（P值）通过，则拒绝零假设。这意味着该类别对排序指标有显著影响——例如，品牌A的商品系统性地集中在销量榜的头部，说明品牌因素对销量有正向的“富集”作用。&lt;/p&gt;
&lt;h4 id=&#34;评估类别对排序的整体贡献&#34;&gt;评估类别对排序的整体贡献&lt;/h4&gt;
&lt;p&gt;传统的分析可能只比较不同类别的均值（如T检验），但这容易被异常值影响，且忽略了整体分布形态。利用GSEA思想，可以捕捉到更细微的趋势。&lt;/p&gt;
&lt;p&gt;例如，某类别的均值可能并不高，但其大部分成员都密集分布在排序列表的前20%区间内，这种“协同趋势”通过均值比较难以发现，但通过基于秩次的富集分析可以敏锐地检测出来。这能回答“是否属于该类别的个体倾向于获得更高的排名”这一问题。&lt;/p&gt;
&lt;h3 id=&#34;实际应用场景举例&#34;&gt;实际应用场景举例&lt;/h3&gt;
&lt;p&gt;为了更好地理解这种迁移应用，可以构建几个具体的非生物学场景。&lt;/p&gt;
&lt;h4 id=&#34;商业与市场分析&#34;&gt;商业与市场分析&lt;/h4&gt;
&lt;p&gt;假设你有一份所有门店的年度利润增长率排名列表。你想知道“位于一线城市的门店”是否表现更好。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;排序列表&lt;/strong&gt;：所有门店按增长率从高到低排序。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;集合&lt;/strong&gt;：所有标记为“一线城市”的门店。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分析结果&lt;/strong&gt;：如果计算出显著的正向NES值，说明“一线城市”这个类别属性对高增长率有显著贡献，即该类门店在榜单头部富集。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;文本挖掘与情感分析&#34;&gt;文本挖掘与情感分析&lt;/h4&gt;
&lt;p&gt;假设你有一篇文章中所有单词的使用频率排序列表。你想知道“表达愤怒情绪的词汇”是否在该文章中过度出现。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;排序列表&lt;/strong&gt;：文章中所有单词按出现频率排序。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;集合&lt;/strong&gt;：预定义的“愤怒情绪”词典。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分析结果&lt;/strong&gt;：如果愤怒词汇显著富集在频率列表顶部，说明该文章的主旨受到愤怒情绪类别的强烈影响。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;基于样本秩次的微生物群落特征富集分析策略&#34;&gt;基于样本秩次的微生物群落特征富集分析策略&lt;/h2&gt;
&lt;p&gt;在经典GSEA中，我们对“基因”排序来检测“通路”的富集；而在微生物群落结构分析的场景中，是对“样本（Sample）”进行排序，来检测“样本特征（Metadata）”的富集。这种方法在统计学上是完全成立的，通常被称为样本级富集分析（Sample-Level Enrichment Analysis, SLEA）的一种变体。&lt;/p&gt;
&lt;h3 id=&#34;构建以样本为核心的分析框架&#34;&gt;构建以样本为核心的分析框架&lt;/h3&gt;
&lt;p&gt;要实现这一分析，首先需要打破传统OTU表的行列思维，将生物学问题映射到秩次统计的数学模型中。&lt;/p&gt;
&lt;h4 id=&#34;数据的角色转换与映射&#34;&gt;数据的角色转换与映射&lt;/h4&gt;
&lt;p&gt;为了适配GSEA算法，你需要对OTU表和元数据（Metadata）进行如下的角色重定义：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;排序实体（原基因位置）：&lt;/strong&gt;
这里的实体不再是OTU或物种，而是你的&lt;strong&gt;样本（Samples）&lt;/strong&gt;。假设你有100个样本，这100个样本就是待排序的列表元素。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;排序指标（原表达量/统计量）：&lt;/strong&gt;
排序的依据是&lt;strong&gt;目标菌（Bacterium X）的相对丰度&lt;/strong&gt;。你需要提取该菌在所有样本中的丰度值，并以此为标准对100个样本进行从高到低的排序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;富集集合（原基因集/通路）：&lt;/strong&gt;
这里的集合不再是KEGG或GO通路，而是&lt;strong&gt;样本的特征分组&lt;/strong&gt;。例如，如果你的元数据中有“分组（对照组/实验组）”、“pH值（高/低）”、“采集地点”等信息，每一个类别（如“实验组”的所有样本ID组成的列表）就是一个“特征集（Feature Set）”。&lt;/p&gt;
&lt;h3 id=&#34;具体实施步骤&#34;&gt;具体实施步骤&lt;/h3&gt;
&lt;p&gt;这一过程可以通过R语言或Python中的相关包来实现，不需要安装GSEA的图形化软件，因为标准软件难以直接处理这种转置的数据结构。&lt;/p&gt;
&lt;h4 id=&#34;排序向量的生成&#34;&gt;排序向量的生成&lt;/h4&gt;
&lt;p&gt;首先需要从OTU表中提取目标数据。锁定你关注的那一个特定菌属或OTU，提取其在所有样本中的丰度数值。&lt;/p&gt;
&lt;p&gt;构建一个命名向量（Named Vector）。向量的数值是该菌的相对丰度，向量的名称（Name/Index）是样本的ID。务必对这个向量进行降序排列（从丰度最高到最低）。如果存在大量零值（即该菌在很多样本中未检出），建议根据实际情况决定是保留零值均作为末尾，还是仅分析检出该菌的样本序列。&lt;/p&gt;
&lt;h4 id=&#34;特征集合的字典构建&#34;&gt;特征集合的字典构建&lt;/h4&gt;
&lt;p&gt;将样本的元数据（Metadata）转换为集合列表（List of Sets）。你需要遍历元数据的每一列特征，将其转化为样本ID的集合。&lt;/p&gt;
&lt;p&gt;对于离散型变量（如分组：Deal/Control）：
直接提取属于“Deal”组的所有样本ID，组成集合A；提取属于“Control”组的所有样本ID，组成集合B。&lt;/p&gt;
&lt;p&gt;对于连续型变量（如BMI、环境因子）：
GSEA处理连续变量需要先将其离散化。你可以根据中位数或四分位数，将连续变量划分为“High_Level”和“Low_Level”两个类别的样本集合。&lt;/p&gt;
&lt;h4 id=&#34;算法运算与统计检验&#34;&gt;算法运算与统计检验&lt;/h4&gt;
&lt;p&gt;利用支持自定义背景集的GSEA工具包进行计算。推荐使用R语言中的&lt;code&gt;fgsea&lt;/code&gt;或&lt;code&gt;clusterProfiler&lt;/code&gt;包。&lt;/p&gt;
&lt;p&gt;将上述准备好的“排序样本向量”作为&lt;code&gt;stats&lt;/code&gt;输入，将“特征集合列表”作为&lt;code&gt;pathways&lt;/code&gt;输入。设置排列次数（nperm）通常为1000或10000次。运行算法后，程序会计算每个特征集合在样本排序列表中的富集分数（ES）和显著性（P值）。&lt;/p&gt;
&lt;h3 id=&#34;结果解读与生物学意义&#34;&gt;结果解读与生物学意义&lt;/h3&gt;
&lt;p&gt;这种分析方式能挖掘出比常规差异分析更丰富的群落生态学规律。&lt;/p&gt;
&lt;h4 id=&#34;理解富集分数nes&#34;&gt;理解富集分数（NES）&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;正向NES（NES &amp;gt; 0）：&lt;/strong&gt;
表示该特征集合（如“高pH环境样本集”）主要集中在排序列表的顶部。这意味着，具有该特征的样本倾向于拥有&lt;strong&gt;更高&lt;/strong&gt;的目标菌相对丰度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;负向NES（NES &amp;lt; 0）：&lt;/strong&gt;
表示该特征集合主要集中在排序列表的底部。这意味着，具有该特征的样本倾向于拥有&lt;strong&gt;更低&lt;/strong&gt;的目标菌相对丰度。&lt;/p&gt;
&lt;h4 id=&#34;识别核心驱动样本leading-edge&#34;&gt;识别核心驱动样本（Leading Edge）&lt;/h4&gt;
&lt;p&gt;通过Leading Edge分析，你可以找出具体是哪些样本导致了显著性。例如，发现“患病组”显著富集在“某致病菌”的高丰度端，你可以进一步查看Leading Edge中的样本ID，这些样本就是该菌爆发的核心宿主。&lt;/p&gt;
&lt;h4 id=&#34;相比传统方法的优势&#34;&gt;相比传统方法的优势&lt;/h4&gt;
&lt;p&gt;相比于直接比较两组样本中该菌丰度的均值（Wilcoxon秩和检验），这种方法的优势在于：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;鲁棒性：&lt;/strong&gt; 对异常值不敏感，关注的是整体分布趋势。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;多维度：&lt;/strong&gt; 可以同时一次性评估几十种环境因子或临床指标对该菌分布的影响，快速筛选出关键的环境驱动因子。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;使用fgsea进行样本特征富集分析的r语言实例&#34;&gt;使用fgsea进行样本特征富集分析的R语言实例&lt;/h2&gt;
&lt;p&gt;这是一个基于R语言包 &lt;code&gt;fgsea&lt;/code&gt; 的完整实例。为了让你能够直接运行并理解流程，我首先构建了一组模拟的OTU表和元数据，然后演示如何将“元数据列”转化为“基因集列表”，最后进行富集分析。&lt;/p&gt;
&lt;h3 id=&#34;数据准备与环境配置&#34;&gt;数据准备与环境配置&lt;/h3&gt;
&lt;p&gt;首先加载必要的包。如果没有安装，请先使用 &lt;code&gt;install.packages(&amp;quot;fgsea&amp;quot;)&lt;/code&gt; 和 &lt;code&gt;install.packages(&amp;quot;tidyverse&amp;quot;)&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&#34;模拟数据生成&#34;&gt;模拟数据生成&lt;/h4&gt;
&lt;p&gt;这里模拟了50个样本，包含一个目标菌（Bacterium_X）和两个元数据特征（分组和来源）。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;suppressPackageStartupMessages({
  library(fgsea)
  library(tidyverse)
})

# 1. 模拟数据构建
set.seed(123)
sample_ids &amp;lt;- paste0(&amp;quot;Sample_&amp;quot;, 1:50)

# 模拟元数据 (Metadata)
# 包含两个分类变量：分组(Group) 和 来源(Source)
metadata &amp;lt;- data.frame(
  SampleID = sample_ids,
  Group = sample(c(&amp;quot;Control&amp;quot;, &amp;quot;Treatment&amp;quot;), 50, replace = TRUE),
  Source = sample(c(&amp;quot;Fecal&amp;quot;, &amp;quot;Oral&amp;quot;), 50, replace = TRUE),
  row.names = sample_ids
)

# 模拟目标菌的相对丰度向量
# 假设 Treatment 组的丰度普遍稍高一点，以便最后能跑出结果
raw_abundance &amp;lt;- numeric(50)
names(raw_abundance) &amp;lt;- sample_ids

for(id in sample_ids) {
  base_val &amp;lt;- runif(1, 0, 100)
  # 如果是处理组，人为增加一点丰度，制造差异
  if(metadata[id, &amp;quot;Group&amp;quot;] == &amp;quot;Treatment&amp;quot;) {
    base_val &amp;lt;- base_val + runif(1, 20, 50)
  }
  raw_abundance[id] &amp;lt;- base_val
}

# 查看一下数据结构
head(metadata)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##          SampleID     Group Source
## Sample_1 Sample_1   Control   Oral
## Sample_2 Sample_2   Control  Fecal
## Sample_3 Sample_3   Control  Fecal
## Sample_4 Sample_4 Treatment  Fecal
## Sample_5 Sample_5   Control  Fecal
## Sample_6 Sample_6 Treatment   Oral
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;head(raw_abundance)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  Sample_1  Sample_2  Sample_3  Sample_4  Sample_5  Sample_6 
##  59.99890  33.28235  48.86130 129.93445  89.03502 129.70587
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;数据标准化&#34;&gt;数据标准化&lt;/h3&gt;
&lt;p&gt;这是最关键的统计学问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;微生物组的数据现状：&lt;/strong&gt; 微生物相对丰度&lt;strong&gt;全部大于或等于0&lt;/strong&gt;。如果你直接用原始丰度做 Stats，Running Sum 只会一直往上加，永远不会下降，这会导致统计分布偏倚，无法正确评估“低丰度”区域的富集。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GSEA的原生逻辑：&lt;/strong&gt; 默认的 &lt;code&gt;scoreType = &amp;quot;std&amp;quot;&lt;/code&gt; 假设排序指标（Stats）有正有负（例如基因表达的 log2FoldChange，上调为正，下调为负）。算法在计算富集分数（Running Sum）时，遇到正值累加，遇到负值扣减，从而形成“峰值”。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# 【修正点 A】：对丰度进行 Z-score 标准化
# 这样可以将非负的丰度值转换为以0为中心的正负值
# 高于均值的变为正数，低于均值的变为负数
abundance_zscore &amp;lt;- (raw_abundance - mean(raw_abundance)) / sd(raw_abundance)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;构建排序列表与特征集合&#34;&gt;构建排序列表与特征集合&lt;/h3&gt;
&lt;p&gt;这是分析中最关键的一步，需要将数据格式转换为 &lt;code&gt;fgsea&lt;/code&gt; 能够识别的格式。&lt;/p&gt;
&lt;h4 id=&#34;步骤一构建排序向量-stats&#34;&gt;步骤一：构建排序向量 (Stats)&lt;/h4&gt;
&lt;p&gt;对应 GSEA 中的“基因排序列表”，这里是按&lt;strong&gt;目标菌丰度&lt;/strong&gt;排序的&lt;strong&gt;样本列表&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# 2. 准备排序向量 (Ranked List)
# 对样本按照目标菌丰度从高到低排序
ranked_samples &amp;lt;- sort(abundance_zscore, decreasing = TRUE)

# 查看前几个样本（丰度最高的样本）
head(ranked_samples)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Sample_28  Sample_4  Sample_6 Sample_27  Sample_8 Sample_35 
##  1.854213  1.820532  1.814276  1.706533  1.618897  1.511349
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;步骤二构建特征集合列表-pathways&#34;&gt;步骤二：构建特征集合列表 (Pathways)&lt;/h4&gt;
&lt;p&gt;对应 GSEA 中的“通路列表”，这里是将&lt;strong&gt;元数据特征&lt;/strong&gt;转化为&lt;strong&gt;样本ID集合&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# 3. 构建特征集合 (Sets / Pathways)
# 我们需要一个 list，list 的名字是特征名，内容是属于该特征的样本ID向量

# 方法：遍历元数据感兴趣的列，使用 split 函数快速分组
metadata_cols &amp;lt;- c(&amp;quot;Group&amp;quot;, &amp;quot;Source&amp;quot;) # 指定要分析的列
sample_sets &amp;lt;- list()

for (col in metadata_cols) {
  # 将样本ID按照该列的分类进行拆分
  # 例如：Group 列会被拆分为 &amp;quot;Group_Control&amp;quot; 和 &amp;quot;Group_Treatment&amp;quot; 两个集合
  split_list &amp;lt;- split(rownames(metadata), metadata[[col]])
  
  # 为了结果清晰，给集合名字加上列名前缀
  names(split_list) &amp;lt;- paste0(col, &amp;quot;_&amp;quot;, names(split_list))
  
  # 加入总列表
  sample_sets &amp;lt;- c(sample_sets, split_list)
}

# 查看生成的集合结构
str(sample_sets)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## List of 4
##  $ Group_Control  : chr [1:30] &amp;quot;Sample_1&amp;quot; &amp;quot;Sample_2&amp;quot; &amp;quot;Sample_3&amp;quot; &amp;quot;Sample_5&amp;quot; ...
##  $ Group_Treatment: chr [1:20] &amp;quot;Sample_4&amp;quot; &amp;quot;Sample_6&amp;quot; &amp;quot;Sample_7&amp;quot; &amp;quot;Sample_8&amp;quot; ...
##  $ Source_Fecal   : chr [1:27] &amp;quot;Sample_2&amp;quot; &amp;quot;Sample_3&amp;quot; &amp;quot;Sample_4&amp;quot; &amp;quot;Sample_5&amp;quot; ...
##  $ Source_Oral    : chr [1:23] &amp;quot;Sample_1&amp;quot; &amp;quot;Sample_6&amp;quot; &amp;quot;Sample_7&amp;quot; &amp;quot;Sample_9&amp;quot; ...
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# 输出示例：
# $ Group_Control : chr [1:26] &amp;quot;Sample_2&amp;quot; &amp;quot;Sample_4&amp;quot; ...
# $ Group_Treatment: chr [1:24] &amp;quot;Sample_1&amp;quot; &amp;quot;Sample_3&amp;quot; ...
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;运行富集分析与可视化&#34;&gt;运行富集分析与可视化&lt;/h3&gt;
&lt;p&gt;使用核心函数 &lt;code&gt;fgsea&lt;/code&gt; 进行计算。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# 4. 运行 fgsea 分析
fgseaRes &amp;lt;- fgsea(
  pathways = sample_sets,   # 你的特征集合列表
  stats    = ranked_samples, # 你的排序样本向量
  minSize  = 5,              # 集合中最少样本数（太少不分析）
  maxSize  = 500            # 集合中最多样本数
)

# 5. 结果整理与展示
# 按照 NES (归一化富集分数) 排序
fgseaRes_tidy &amp;lt;- fgseaRes %&amp;gt;%
  arrange(desc(NES)) %&amp;gt;%
  select(pathway, pval, padj, NES, size)

print(fgseaRes_tidy)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##            pathway         pval         padj        NES  size
##             &amp;lt;char&amp;gt;        &amp;lt;num&amp;gt;        &amp;lt;num&amp;gt;      &amp;lt;num&amp;gt; &amp;lt;int&amp;gt;
## 1: Group_Treatment 1.896680e-07 3.793361e-07  2.5942035    20
## 2:     Source_Oral 6.013865e-01 8.018486e-01  0.8920200    23
## 3:    Source_Fecal 9.763113e-01 9.763113e-01  0.5533213    27
## 4:   Group_Control 8.471189e-08 3.388475e-07 -2.7103134    30
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# 6. 可视化 (Enrichment Plot)
# 绘制富集程度最高的那个特征
top_pathway &amp;lt;- fgseaRes_tidy$pathway[1]

plotEnrichment(sample_sets[[top_pathway]], ranked_samples) + 
  labs(title = paste(&amp;quot;Enrichment of feature:&amp;quot;, top_pathway),
       subtitle = &amp;quot;Ranked by Bacterium Abundance&amp;quot;,
       x = &amp;quot;Rank in Ordered Dataset (Samples)&amp;quot;,
       y = &amp;quot;Enrichment Score&amp;quot;) +
  theme_bw()
&lt;/code&gt;&lt;/pre&gt;
&lt;img src=&#34;bio-spring/post/2025/11/21/gsea-in-microbiome-analysis/index_files/figure-html/unnamed-chunk-5-1.png&#34; width=&#34;672&#34; /&gt;
&lt;h3 id=&#34;结果解读指南&#34;&gt;结果解读指南&lt;/h3&gt;
&lt;p&gt;运行上述代码后，你需要关注 &lt;code&gt;fgseaRes_tidy&lt;/code&gt; 表格中的几个关键指标：&lt;/p&gt;
&lt;h4 id=&#34;nes-normalized-enrichment-score&#34;&gt;NES (Normalized Enrichment Score)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;NES &amp;gt; 0 (正值):&lt;/strong&gt;
表示该组样本（如 &lt;code&gt;Group_Treatment&lt;/code&gt;）主要聚集在排序列表的左侧（顶部）。
&lt;strong&gt;含义：&lt;/strong&gt; &lt;code&gt;Group_Treatment&lt;/code&gt; 这一特征与该菌的&lt;strong&gt;高丰度&lt;/strong&gt;正相关。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NES &amp;lt; 0 (负值):&lt;/strong&gt;
表示该组样本主要聚集在排序列表的右侧（底部）。
&lt;strong&gt;含义：&lt;/strong&gt; 该特征与该菌的&lt;strong&gt;低丰度&lt;/strong&gt;相关。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;padj-adjusted-p-value&#34;&gt;padj (Adjusted P-value)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;如果 &lt;code&gt;padj &amp;lt; 0.05&lt;/code&gt;，说明这种聚集不是随机发生的，具有统计学显著性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;可视化图-barcode-plot&#34;&gt;可视化图 (Barcode Plot)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;X轴：&lt;/strong&gt; 代表所有样本，从左到右该菌丰度依次降低。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;黑色竖线：&lt;/strong&gt; 代表属于该特征（如 &lt;code&gt;Group_Treatment&lt;/code&gt;）的样本所在的位置。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;绿色曲线：&lt;/strong&gt; 富集分数的走势。如果曲线在左侧高高隆起，说明该特征的样本显著富集在高丰度区域。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;gsea前导边缘分析识别核心驱动样本&#34;&gt;GSEA前导边缘分析：识别核心驱动样本&lt;/h2&gt;
&lt;p&gt;Leading Edge Analysis（前导边缘分析）是GSEA结果解读中至关重要的一步,能够帮助我们定位哪些具体元素对富集信号贡献最大。&lt;/p&gt;
&lt;h3 id=&#34;前导边缘子集的定义&#34;&gt;前导边缘子集的定义&lt;/h3&gt;
&lt;p&gt;前导边缘子集（Leading Edge Subset）被定义为：从排序列表的起始位置开始，一直到出现富集分数最大值（Peak）的那一刻为止，在此区间内出现的所有属于该特征集合的成员。&lt;/p&gt;
&lt;p&gt;在经典的基因集富集分析中，这些成员是基因；而在本文介绍的&lt;strong&gt;样本级富集分析&lt;/strong&gt;中，这些成员是&lt;strong&gt;样本ID&lt;/strong&gt;。前导边缘子集被认为是该特征集合富集信号的核心贡献者。&lt;/p&gt;
&lt;h3 id=&#34;在微生物组分析中的意义&#34;&gt;在微生物组分析中的意义&lt;/h3&gt;
&lt;p&gt;在微生物群落分析场景中，前导边缘样本具有特殊的生物学意义：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;识别关键宿主样本：&lt;/strong&gt; 当我们发现某个样本特征（如&amp;quot;患病组&amp;quot;）在某个菌的高丰度端显著富集时，前导边缘子集包含的样本ID就是该菌丰度最极端的核心样本。这些样本可能代表了疾病最严重的个体，或是环境因子作用最强烈的生态位。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;筛选代表性样本：&lt;/strong&gt; 在后续的深度测序、代谢组学或其他高成本分析中，可以优先选择前导边缘样本进行验证，因为它们最能代表该特征与目标菌丰度之间的关联模式。&lt;/p&gt;
&lt;h3 id=&#34;提取前导边缘样本&#34;&gt;提取前导边缘样本&lt;/h3&gt;
&lt;p&gt;在使用 &lt;code&gt;fgsea&lt;/code&gt; 包进行分析时，结果表格中已经自动包含了一个名为 &lt;code&gt;leadingEdge&lt;/code&gt; 的列。这一列是一个列表（List）结构，存储了每个特征集合的具体核心样本ID。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# 假设 fgseaRes 是之前运行得到的结果对象
# 1. 查看结果表结构，注意 leadingEdge 列
head(fgseaRes)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##            pathway         pval         padj    log2err         ES        NES
##             &amp;lt;char&amp;gt;        &amp;lt;num&amp;gt;        &amp;lt;num&amp;gt;      &amp;lt;num&amp;gt;      &amp;lt;num&amp;gt;      &amp;lt;num&amp;gt;
## 1:   Group_Control 8.471189e-08 3.388475e-07 0.70497572 -0.8474911 -2.7103134
## 2: Group_Treatment 1.896680e-07 3.793361e-07 0.69013246  0.8730745  2.5942035
## 3:    Source_Fecal 9.763113e-01 9.763113e-01 0.03911552  0.1816169  0.5533213
## 4:     Source_Oral 6.013865e-01 8.018486e-01 0.06266182  0.2937660  0.8920200
##     size                                                    leadingEdge
##    &amp;lt;int&amp;gt;                                                         &amp;lt;list&amp;gt;
## 1:    30 Sample_9,Sample_19,Sample_39,Sample_20,Sample_18,Sample_31,...
## 2:    20   Sample_28,Sample_4,Sample_6,Sample_27,Sample_8,Sample_35,...
## 3:    27  Sample_28,Sample_4,Sample_8,Sample_22,Sample_11,Sample_10,...
## 4:    23     Sample_6,Sample_27,Sample_35,Sample_32,Sample_12,Sample_48
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# 2. 提取富集最显著特征的前导边缘样本
# 先按 NES 降序排列，取第一行
top_feature_info &amp;lt;- fgseaRes %&amp;gt;%
  arrange(desc(NES)) %&amp;gt;%
  slice(1)

# 获取特征名称
feature_name &amp;lt;- top_feature_info$pathway

# 获取 Leading Edge 样本列表 (这是一个 list 元素，需要 unlist)
core_samples &amp;lt;- unlist(top_feature_info$leadingEdge)

# 打印结果
cat(&amp;quot;Top Feature:&amp;quot;, feature_name, &amp;quot;\n&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Top Feature: Group_Treatment
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;cat(&amp;quot;Number of Core Samples:&amp;quot;, length(core_samples), &amp;quot;\n&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Number of Core Samples: 15
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;cat(&amp;quot;Core Sample IDs:\n&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Core Sample IDs:
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;print(core_samples)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] &amp;quot;Sample_28&amp;quot; &amp;quot;Sample_4&amp;quot;  &amp;quot;Sample_6&amp;quot;  &amp;quot;Sample_27&amp;quot; &amp;quot;Sample_8&amp;quot;  &amp;quot;Sample_35&amp;quot;
##  [7] &amp;quot;Sample_32&amp;quot; &amp;quot;Sample_22&amp;quot; &amp;quot;Sample_12&amp;quot; &amp;quot;Sample_48&amp;quot; &amp;quot;Sample_11&amp;quot; &amp;quot;Sample_13&amp;quot;
## [13] &amp;quot;Sample_17&amp;quot; &amp;quot;Sample_43&amp;quot; &amp;quot;Sample_40&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;# 3. 提取这些核心样本的丰度值进行进一步分析
core_sample_abundance &amp;lt;- abundance_zscore[core_samples]
cat(&amp;quot;\nAbundance distribution of core samples:\n&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Abundance distribution of core samples:
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;summary(core_sample_abundance)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##  0.3488  0.8236  1.2385  1.2063  1.6627  1.8542
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;可视化前导边缘的重叠&#34;&gt;可视化前导边缘的重叠&lt;/h3&gt;
&lt;p&gt;当发现多个样本特征显著富集时，可以使用 UpSet 图来展示它们的前导边缘样本是否存在重叠。这能回答一个重要问题：&lt;strong&gt;不同的样本特征是否由同一批核心样本驱动？&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(UpSetR)

# 1. 筛选显著富集的特征（例如 padj &amp;lt; 0.05）
sig_features &amp;lt;- fgseaRes %&amp;gt;%
  filter(padj &amp;lt; 0.05) %&amp;gt;%
  arrange(desc(abs(NES)))

# 如果显著特征太多，只取前5个
if(nrow(sig_features) &amp;gt; 5) {
  sig_features &amp;lt;- sig_features %&amp;gt;% head(5)
}

# 2. 构建 UpSetR 需要的列表数据
# 列表名为特征名，列表内容为该特征的 leadingEdge 样本
list_for_upset &amp;lt;- setNames(sig_features$leadingEdge, sig_features$pathway)

# 3. 绘制 UpSet 图
# 这张图能清晰展示哪些样本是多个特征共有的（关键驱动样本）
upset(fromList(list_for_upset), 
      order.by = &amp;quot;freq&amp;quot;,
      main.bar.color = &amp;quot;steelblue&amp;quot;,
      sets.bar.color = &amp;quot;darkgreen&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning: `aes_string()` was deprecated in ggplot2 3.0.0.
## ℹ Please use tidy evaluation idioms with `aes()`.
## ℹ See also `vignette(&amp;quot;ggplot2-in-packages&amp;quot;)` for more information.
## ℹ The deprecated feature was likely used in the UpSetR package.
##   Please report the issue to the authors.
## This warning is displayed once every 8 hours.
## Call `lifecycle::last_lifecycle_warnings()` to see where this warning was
## generated.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.
## ℹ Please use `linewidth` instead.
## ℹ The deprecated feature was likely used in the UpSetR package.
##   Please report the issue to the authors.
## This warning is displayed once every 8 hours.
## Call `lifecycle::last_lifecycle_warnings()` to see where this warning was
## generated.
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## `geom_line()`: Each group consists of only one observation.
## ℹ Do you need to adjust the group aesthetic?
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning: The `size` argument of `element_line()` is deprecated as of ggplot2 3.4.0.
## ℹ Please use the `linewidth` argument instead.
## ℹ The deprecated feature was likely used in the UpSetR package.
##   Please report the issue to the authors.
## This warning is displayed once every 8 hours.
## Call `lifecycle::last_lifecycle_warnings()` to see where this warning was
## generated.
&lt;/code&gt;&lt;/pre&gt;
&lt;img src=&#34;bio-spring/post/2025/11/21/gsea-in-microbiome-analysis/index_files/figure-html/unnamed-chunk-7-1.png&#34; width=&#34;672&#34; /&gt;
&lt;h3 id=&#34;结果解读&#34;&gt;结果解读&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;交集部分（Intersection）：&lt;/strong&gt; 如果多个特征的前导边缘样本存在大量重叠，说明这些样本同时具备多种极端特征。例如，某些样本可能既属于&amp;quot;高pH环境&amp;quot;又属于&amp;quot;患病组&amp;quot;的前导边缘，暗示这些特征可能协同影响目标菌的丰度分布。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特有部分：&lt;/strong&gt; 仅属于某一个特征的前导边缘样本，则代表了该特征的独特影响。这些样本可以帮助我们区分不同环境因子或临床指标的独立效应。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;生物学应用：&lt;/strong&gt; 通过前导边缘分析识别出的核心样本，可以作为后续机制研究的重点对象，例如进行宏基因组测序、培养组学或代谢物分析，以揭示该菌与宿主/环境互作的分子机制。&lt;/p&gt;

        </description>
      </item>
    
  </channel>
</rss>
