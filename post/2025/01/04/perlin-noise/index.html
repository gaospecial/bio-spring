<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title> 柏林噪声 | BIO-SPRING</title>
    
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@xiee/utils@v1.13.54/css/article.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@xiee/utils/css/heading-anchor.min.css">
    <link rel="stylesheet" href="/bio-spring/css/style.css" />
    <link rel="stylesheet" href="/bio-spring/css/fonts.css" />
    <link rel="stylesheet" href="/bio-spring/css/custom.css" />
    
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="柏林噪声">
  <meta name="twitter:description" content="最近看视频了解到有一个可用于生成游戏地图中地形、环境差异的算法，听起来像是以德国地名命名的噪音算法——柏林噪声。
它的名字原本叫做 Perlin Noise，由 Ken Perlin 发明并以他的名字命名。虽然听起来与德国地名有关，但实际上与地名无关，而是对 Perlin Noise 的音译误读。柏林噪音是生成自然纹理（如地形、云层和水流）最常用的噪声算法之一，广泛用于游戏开发和计算机图形学中。
“柏林噪音”是一种常用于生成自然纹理的伪随机噪声算法，尤其适合生成游戏地图中的地形、高度图、云层等。
Perlin Noise 的特点包括：
平滑性：相比纯粹的随机噪声，Perlin Noise 是一种连续的噪声，可以生成自然的、无明显断点的纹理。 多分辨率特性：通过组合不同尺度的 Perlin Noise，可以生成更复杂的分形纹理，适用于模拟自然现象。 高效性：设计时兼顾了计算效率，适合实时生成大规模地图。 生成柏林噪声的实例 以下是使用 R 生成和可视化 Perlin 噪音（“柏林噪音”）的代码。我们将使用 ambient 和 ggplot2 包来生成和展示噪声图案。
安装依赖包 ambient 是生成柏林噪声的 R 语言软件包。如果尚未安装，可以运行以下代码：
install.packages(&#34;ambient&#34;) ambient 包提供了生成多种噪声模式的函数，包括 Perlin 噪声、Simplex 噪声等。在这里，我们将使用 gen_perlin 函数生成 Perlin 噪声。
生成和可视化 Perlin 噪音 # 加载必要的包 library(ambient) library(dplyr) ## ## Attaching package: &#39;dplyr&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union library(ggplot2) # 设置噪音网格大小 grid_size = 200 # 生成 Perlin 噪音 noise_data = long_grid(x = seq(0, 5, length.out = grid_size), y = seq(0, 5, length.out = grid_size)) |&gt; mutate(value = gen_perlin(x, y, frequency = 1, seed = 42)) # 使用 ggplot2 可视化 ggplot(noise_data, aes(x, y, fill = value)) &#43; geom_raster() &#43; scale_fill_viridis_c() &#43; coord_equal() &#43; theme_minimal() &#43; labs(title = &#34;Perlin Noise Visualization&#34;, fill = &#34;Value&#34;) 代码解释 long_grid：生成一个二维网格，x 和 y 定义了网格的范围和密度。 gen_perlin：生成 Perlin 噪音，支持设置频率和种子以控制噪音的细节和重复性。 geom_raster：绘制栅格图，适合显示二维噪音数据。 scale_fill_viridis_c：使用 Viridis 配色方案，增强可读性。 运行效果 代码将生成一个平滑、连续的 Perlin 噪音图，可用于地图生成、地形建模或其他游戏开发用途。你可以调整网格大小（grid_size）、频率（frequency）和种子值（seed）以获得不同的效果。">


  </head>

  <body>

    <nav class="menu sticky-top">
    <ul>
      <li class="left">
        <a href="/"><span>BIO-SPRING</span></a>
      </li>
      
      <li>
        <a href="/bio-spring">Home</a>
      </li>
      
      <li>
        <a href="/bio-spring/post/">Blog Post</a>
      </li>
      
      <li>
        <a href="/bio-spring/publication/full-publication-list/">Publication</a>
      </li>
      
      <li>
        <a href="/bio-spring/work/">Work</a>
      </li>
      
      <li id="menu-search">
        <a href="/bio-spring/#">Search</a>
      </li>
      
    </ul>
    </nav>


<div class="container single">
<main>

<div class="article-meta">
<h1><span class="title">柏林噪声</span></h1>

<h3 class="author">
gaoch
</h3>

<h3 class="date">2025-01-04</h3>
<p class="terms">
  
  
  Categories: <a href="/categories/%E4%BF%A1%E6%81%AF%E6%8A%80%E6%9C%AF">信息技术</a> 
  
  
  
  Tags: <a href="/tags/r">R</a> 
  
  
</p>
</div>

<div class="article">
<p>最近看视频了解到有一个可用于生成游戏地图中地形、环境差异的算法，听起来像是以德国地名命名的噪音算法——<strong>柏林噪声</strong>。</p>
<p>它的名字原本叫做 <strong>Perlin Noise</strong>，由 Ken Perlin 发明并以他的名字命名。虽然听起来与德国地名有关，但实际上与地名无关，而是对 <strong>Perlin Noise</strong> 的音译误读。柏林噪音是生成自然纹理（如地形、云层和水流）最常用的噪声算法之一，广泛用于游戏开发和计算机图形学中。</p>
<p>“柏林噪音”是一种常用于生成自然纹理的伪随机噪声算法，尤其适合生成游戏地图中的地形、高度图、云层等。</p>
<p>Perlin Noise 的特点包括：</p>
<ul>
<li><strong>平滑性</strong>：相比纯粹的随机噪声，Perlin Noise 是一种连续的噪声，可以生成自然的、无明显断点的纹理。</li>
<li><strong>多分辨率特性</strong>：通过组合不同尺度的 Perlin Noise，可以生成更复杂的分形纹理，适用于模拟自然现象。</li>
<li><strong>高效性</strong>：设计时兼顾了计算效率，适合实时生成大规模地图。</li>
</ul>
<h2 id="生成柏林噪声的实例">生成柏林噪声的实例</h2>
<p>以下是使用 R 生成和可视化 Perlin 噪音（“柏林噪音”）的代码。我们将使用 <code>ambient</code> 和 <code>ggplot2</code> 包来生成和展示噪声图案。</p>
<h3 id="安装依赖包">安装依赖包</h3>
<p><code>ambient</code> 是生成柏林噪声的 R 语言软件包。如果尚未安装，可以运行以下代码：</p>
<pre><code class="language-r">install.packages(&quot;ambient&quot;)
</code></pre>
<p><code>ambient</code> 包提供了生成多种噪声模式的函数，包括 Perlin 噪声、Simplex 噪声等。在这里，我们将使用 <code>gen_perlin</code> 函数生成 Perlin 噪声。</p>
<h3 id="生成和可视化-perlin-噪音">生成和可视化 Perlin 噪音</h3>
<pre><code class="language-r"># 加载必要的包
library(ambient)
library(dplyr)
</code></pre>
<pre><code>## 
## Attaching package: 'dplyr'
</code></pre>
<pre><code>## The following objects are masked from 'package:stats':
## 
##     filter, lag
</code></pre>
<pre><code>## The following objects are masked from 'package:base':
## 
##     intersect, setdiff, setequal, union
</code></pre>
<pre><code class="language-r">library(ggplot2)

# 设置噪音网格大小
grid_size = 200

# 生成 Perlin 噪音
noise_data = long_grid(x = seq(0, 5, length.out = grid_size), 
                       y = seq(0, 5, length.out = grid_size)) |&gt;
  mutate(value = gen_perlin(x, y, frequency = 1, seed = 42))

# 使用 ggplot2 可视化
ggplot(noise_data, aes(x, y, fill = value)) +
  geom_raster() +
  scale_fill_viridis_c() +
  coord_equal() +
  theme_minimal() +
  labs(title = &quot;Perlin Noise Visualization&quot;, fill = &quot;Value&quot;)
</code></pre>
<img src="bio-spring/post/2025/01/04/perlin-noise/index.zh_files/figure-html/unnamed-chunk-1-1.png" width="672" />
<h3 id="代码解释">代码解释</h3>
<ol>
<li><strong><code>long_grid</code></strong>：生成一个二维网格，<code>x</code> 和 <code>y</code> 定义了网格的范围和密度。</li>
<li><strong><code>gen_perlin</code></strong>：生成 Perlin 噪音，支持设置频率和种子以控制噪音的细节和重复性。</li>
<li><strong><code>geom_raster</code></strong>：绘制栅格图，适合显示二维噪音数据。</li>
<li><strong><code>scale_fill_viridis_c</code></strong>：使用 Viridis 配色方案，增强可读性。</li>
</ol>
<h3 id="运行效果">运行效果</h3>
<p>代码将生成一个平滑、连续的 Perlin 噪音图，可用于地图生成、地形建模或其他游戏开发用途。你可以调整网格大小（<code>grid_size</code>）、频率（<code>frequency</code>）和种子值（<code>seed</code>）以获得不同的效果。</p>
<h2 id="使用-ambient-包生成更多噪声">使用 <code>ambient</code> 包生成更多噪声</h2>
<h3 id="simplex-噪声">Simplex 噪声</h3>
<p>Simplex 噪声是 Perlin 噪声的改进版本，具有更高的计算效率和更好的平滑性。在 <code>ambient</code> 包中，我们可以使用 <code>gen_simplex</code> 函数生成 Simplex 噪声。</p>
<pre><code class="language-r"># 生成 Simplex 噪音
noise_data = long_grid(x = seq(0, 5, length.out = grid_size), 
                       y = seq(0, 5, length.out = grid_size)) |&gt;
  mutate(value = gen_simplex(x, y, frequency = 1, seed = 42))

# 使用 ggplot2 可视化
ggplot(noise_data, aes(x, y, fill = value)) +
  geom_raster() +
  scale_fill_viridis_c() +
  coord_equal() +
  theme_minimal() +
  labs(title = &quot;Simplex Noise Visualization&quot;, fill = &quot;Value&quot;)
</code></pre>
<img src="bio-spring/post/2025/01/04/perlin-noise/index.zh_files/figure-html/unnamed-chunk-2-1.png" width="672" />
<h3 id="worley-噪声">Worley 噪声</h3>
<p>Worley 噪声是一种基于点的噪声算法，通过计算每个点到最近的若干个种子点的距离来生成噪声。在 <code>ambient</code> 包中，我们可以使用 <code>gen_worley</code> 函数生成 Worley 噪声。</p>
<pre><code class="language-r"># 生成 Worley 噪音
noise_data = long_grid(x = seq(0, 5, length.out = grid_size), 
                       y = seq(0, 5, length.out = grid_size)) |&gt;
  mutate(value = gen_worley(x, y, frequency = 1, seed = 42))

# 使用 ggplot2 可视化
ggplot(noise_data, aes(x, y, fill = value)) +
  geom_raster() +
  scale_fill_viridis_c() +
  coord_equal() +
  theme_minimal() +
  labs(title = &quot;Worley Noise Visualization&quot;, fill = &quot;Value&quot;)
</code></pre>
<img src="bio-spring/post/2025/01/04/perlin-noise/index.zh_files/figure-html/unnamed-chunk-3-1.png" width="672" />
<h3 id="value-噪声">Value 噪声</h3>
<p>Value 噪声是一种简单的噪声算法，通过在网格点上生成随机值并进行插值来生成噪声。在 <code>ambient</code> 包中，我们可以使用 <code>gen_value</code> 函数生成 Value 噪声。</p>
<pre><code class="language-r"># 生成 Value 噪音
noise_data = long_grid(x = seq(0, 5, length.out = grid_size), 
                       y = seq(0, 5, length.out = grid_size)) |&gt;
  mutate(value = gen_value(x, y, frequency = 1, seed = 42))

# 使用 ggplot2 可视化
ggplot(noise_data, aes(x, y, fill = value)) +
  geom_raster() +
  scale_fill_viridis_c() +
  coord_equal() +
  theme_minimal() +
  labs(title = &quot;Value Noise Visualization&quot;, fill = &quot;Value&quot;)
</code></pre>
<img src="bio-spring/post/2025/01/04/perlin-noise/index.zh_files/figure-html/unnamed-chunk-4-1.png" width="672" />
<h3 id="cubic-噪声">Cubic 噪声</h3>
<p>Cubic 噪声是一种基于立方插值的噪声算法，通过在网格点上生成随机值并进行立方插值来生成噪声。在 <code>ambient</code> 包中，我们可以使用 <code>gen_cubic</code> 函数生成 Cubic 噪声。</p>
<pre><code class="language-r"># 生成 Cubic 噪音
noise_data = long_grid(x = seq(0, 5, length.out = grid_size), 
                       y = seq(0, 5, length.out = grid_size)) |&gt;
  mutate(value = gen_cubic(x, y, frequency = 1, seed = 42))

# 使用 ggplot2 可视化
ggplot(noise_data, aes(x, y, fill = value)) +
  geom_raster() +
  scale_fill_viridis_c() +
  coord_equal() +
  theme_minimal() +
  labs(title = &quot;Cubic Noise Visualization&quot;, fill = &quot;Value&quot;)
</code></pre>
<img src="bio-spring/post/2025/01/04/perlin-noise/index.zh_files/figure-html/unnamed-chunk-5-1.png" width="672" />
<h3 id="waves-噪声">Waves 噪声</h3>
<p>Waves 噪声是一种基于正弦波的噪声算法，通过在网格点上生成正弦波并进行插值来生成噪声。在 <code>ambient</code> 包中，我们可以使用 <code>gen_waves</code> 函数生成 Waves 噪声。</p>
<pre><code class="language-r"># 生成 Waves 噪音
noise_data = long_grid(x = seq(0, 5, length.out = grid_size), 
                       y = seq(0, 5, length.out = grid_size)) |&gt;
  mutate(value = gen_waves(x, y, frequency = 1, seed = 42))

# 使用 ggplot2 可视化
ggplot(noise_data, aes(x, y, fill = value)) +
  geom_raster() +
  scale_fill_viridis_c() +
  coord_equal() +
  theme_minimal() +
  labs(title = &quot;Waves Noise Visualization&quot;, fill = &quot;Value&quot;)
</code></pre>
<img src="bio-spring/post/2025/01/04/perlin-noise/index.zh_files/figure-html/unnamed-chunk-6-1.png" width="672" />
<h3 id="生成-checkerborad-模式">生成 checkerborad 模式</h3>
<p>Checkerboard 模式是一种简单的噪声模式，通过在网格点上生成交替的黑白格子来生成噪声。在 <code>ambient</code> 包中，我们可以使用 <code>gen_checkerboard</code> 函数生成 Checkerboard 噪声。</p>
<pre><code class="language-r"># 生成 Checkerboard 噪音
noise_data = long_grid(x = seq(0, 5, length.out = grid_size), 
                       y = seq(0, 5, length.out = grid_size)) |&gt;
  mutate(value = gen_checkerboard(x, y, frequency = 1, seed = 42))

# 使用 ggplot2 可视化
ggplot(noise_data, aes(x, y, fill = value)) +
  geom_raster() +
  scale_fill_viridis_c() +
  coord_equal() +
  theme_minimal() +
  labs(title = &quot;Checkerboard Noise Visualization&quot;, fill = &quot;Value&quot;)
</code></pre>
<img src="bio-spring/post/2025/01/04/perlin-noise/index.zh_files/figure-html/unnamed-chunk-7-1.png" width="672" />
<h3 id="生成-spheres-模式">生成 spheres 模式</h3>
<p>Spheres 模式是一种基于球体的噪声模式，通过在网格点上生成球体并进行插值来生成噪声。在 <code>ambient</code> 包中，我们可以使用 <code>gen_spheres</code> 函数生成 Spheres 噪声。</p>
<pre><code class="language-r"># 生成 Spheres 噪音
noise_data = long_grid(x = seq(0, 5, length.out = grid_size), 
                       y = seq(0, 5, length.out = grid_size)) |&gt;
  mutate(value = gen_spheres(x, y, frequency = 1, seed = 42))

# 使用 ggplot2 可视化
ggplot(noise_data, aes(x, y, fill = value)) +
  geom_raster() +
  scale_fill_viridis_c() +
  coord_equal() +
  theme_minimal() +
  labs(title = &quot;Spheres Noise Visualization&quot;, fill = &quot;Value&quot;)
</code></pre>
<img src="bio-spring/post/2025/01/04/perlin-noise/index.zh_files/figure-html/unnamed-chunk-8-1.png" width="672" />
<h3 id="组合噪声">组合噪声</h3>
<p>将柏林噪声与 Worley 噪声、Value 噪声等组合在一起，可以生成更加复杂的噪声模式。</p>
<p>以下是结合 <strong>Perlin 噪声</strong>、<strong>Worley 噪声</strong> 和 <strong>Value 噪声</strong> 的方法，生成复杂的噪声图案并可视化。我们继续使用 R 中的 <code>ambient</code> 和 <code>ggplot2</code> 包实现。</p>
<h3 id="代码实现">代码实现</h3>
<pre><code class="language-r"># 设置网格大小和范围
grid_size = 200
x_range = seq(0, 5, length.out = grid_size)
y_range = seq(0, 5, length.out = grid_size)

# 创建网格
noise_data = long_grid(x = x_range, y = y_range)

# 生成 Perlin 噪声
noise_data = noise_data |&gt;
  mutate(perlin = gen_perlin(x, y, frequency = 2, seed = 42))

# 生成 Worley 噪声
noise_data = noise_data |&gt;
  mutate(worley = gen_worley(x, y, frequency = 2, seed = 42, value = &quot;distance&quot;))

# 生成 Value 噪声
noise_data = noise_data |&gt;
  mutate(value_noise = gen_value(x, y, frequency = 2, seed = 42))

# 合并噪声（例如取加权平均或乘积）
noise_data = noise_data |&gt;
  mutate(combined = 0.4 * perlin + 0.4 * worley + 0.2 * value_noise)

# 可视化
ggplot(noise_data, aes(x, y, fill = combined)) +
  geom_raster() +
  scale_fill_viridis_c() +
  coord_equal() +
  theme_minimal() +
  labs(title = &quot;Combined Noise: Perlin, Worley, and Value&quot;, fill = &quot;Value&quot;)
</code></pre>
<img src="bio-spring/post/2025/01/04/perlin-noise/index.zh_files/figure-html/unnamed-chunk-9-1.png" width="672" />

</div>
</main>

<section class="appendix">


<div>
  <div class="side side-left"><h3>作者简介</h3></div>
  <div>





<div>Chun-Hui Gao is a Research Associate at <a href="http://www.hzau.edu.cn">Huazhong Agricultural University</a>.</div>


</div>
</div>






<div>
  <div class="side side-left"><h3>重复使用</h3></div>
  Text and figures are licensed under <a href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution CC BY 4.0</a>. The source code is licensed under MIT. The full source is available at <a href="https://github.com/yihui/hugo-prose">https://github.com/yihui/hugo-prose</a>.
</div>



<div>
  <div class="side side-left"><h3>欢迎修订</h3></div>
  
  
  
    
  
  如果您发现本文里含有任何错误（包括错别字和标点符号），欢迎<a href="https://github.com/gaospecial/bio-spring/edit/master/content/post/2025-01-04-perlin-noise/index.zh.Rmd" id="edit-link">在本站的 GitHub 项目里提交修订意见。</a>
</div>




<div>
  <div class="side side-left"><h3>引用本文</h3></div>
  <p>如果您使用了本文的内容，请按照以下方式引用：</p>
  <pre><code>gaoch (2025). 柏林噪声. BIO-SPRING. bio-spring/post/2025/01/04/perlin-noise/</code></pre>
  <p>BibTeX citation</p>
  <pre><code>@misc{
  title = "柏林噪声",
  author = "gaoch",
  year = "2025",
  journal = "BIO-SPRING",
  note = "bio-spring/post/2025/01/04/perlin-noise/"
}</code></pre>
</div>

</section>



<nav class="post-nav">
  <span class="nav-next">&larr; <a href="bio-spring/post/2024/12/29/clusterprofiler-metabolite-enrichment-analysis/" title=下一篇&#32;(旧)>ClusterProfiler做代谢物富集分析</a></span>
  &hercon;
  <span class="nav-prev"><a href="bio-spring/post/2025/02/17/data-driven-reproducible-study/" title=上一篇&#32;(新)>数据驱动的可重复性研究</a> &rarr;</span>
</nav>




<section class="comments">
  <div id="disqus_thread"></div>
  <script>
  var disqus_config = function () {
  
  };
  (function() {
    var inIFrame = function() {
      var iframe = true;
      try { iframe = window.self !== window.top; } catch (e) {}
      return iframe;
    };
    if (inIFrame()) return;
    var disqus_js = '//bio-spring.disqus.com/embed.js';
    var d = document, s = d.createElement('script');
    s.src = disqus_js; s.async = true;
    s.setAttribute('data-timestamp', +new Date());
    var t = d.getElementById('disqus_thread');
    var b = false, l = function(scroll) {
      if (b) return;
      (d.head || d.body).appendChild(s); b = true;
      if (scroll) t.scrollIntoView();
    }
    s.onerror = function(e) {
      if (sessionStorage.getItem('failure-note')) return;
      t.innerText = 'Sorry, but you cannot make comments because Disqus failed to load for some reason. It is known to be blocked in China. If you are sure it is not blocked in your region, please refresh the page. 中国大陆地区读者需要翻墙才能发表评论。';
      t.style.border = '1px dashed';
      t.style.padding = '.5em';
      t.style.background = 'lightyellow';
      sessionStorage.setItem('failure-note', true);
    };
    
    if (location.hash.match(/^#comment-[0-9]+$/)) return l(true);
    var c = function() {
      if (b) return;
      var rect = t.getBoundingClientRect();
      if (rect.top < window.innerHeight && rect.bottom >= 0) l();
    };
    window.addEventListener('load', c);
    d.addEventListener('scroll', c);
  })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</section>


</div>


  <footer>
  
<script src="https://cdn.jsdelivr.net/npm/fuse.js@6.6.2"></script>





      <script async src="https://www.googletagmanager.com/gtag/js?id=G-77M8KZTCMR"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-77M8KZTCMR');
        }
      </script>


<script src="https://cdn.jsdelivr.net/combine/npm/@xiee/utils/js/number-sections.min.js,npm/@xiee/utils/js/toc.min.js,npm/@xiee/utils/js/toc-highlight.min.js,npm/@xiee/utils/js/sidenotes.min.js,npm/@xiee/utils/js/right-quote.min.js,npm/@xiee/utils/js/center-img.min.js,npm/@xiee/utils/js/fix-pandoc.min.js,npm/@xiee/utils/js/heading-anchor.min.js" defer></script>



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@xiee/utils/css/prism-xcode.min.css">
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js" defer></script>


  <div class="footer">
  
  <ul class="copyright">
    <li>© <a href="https://bio-spring.top">Bio-Spring</a> 2006 &ndash; 2025 <a href="https://beian.miit.gov.cn">豫ICP备2021003240号</a></li>
  </ul>
  
  <ul>
    
    <li>
      <a href="/bio-spring/404.html">Contact</a>
    </li>
    
    <li class="optional">
      <a href="/bio-spring/categories/">Categories</a>
    </li>
    
    <li class="optional">
      <a href="/bio-spring/tags/">Tags</a>
    </li>
    
    <li id="menu-edit">
      <a href="#">Suggest an edit</a>
    </li>
    
    <li>
      <a href="#">Back to top</a>
    </li>
    
  </ul>
  </div>
  
  </footer>
  <script src="/bio-spring/js/features.js" defer></script>
  </body>
</html>

