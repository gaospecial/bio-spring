<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>statistics on Hugo Prose</title>
    <link>/tags/statistics/</link>
    <description>Recent content in statistics on Hugo Prose</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 12 Apr 2020 00:00:00 +0000</lastBuildDate><atom:link href="/tags/statistics/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>正态分布的转换</title>
      <link>/post/2020/04/12/normal-distribution-transformation/</link>
      <pubDate>Sun, 12 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>/post/2020/04/12/normal-distribution-transformation/</guid>
      <description>数据满足正态分布是进行很多统计分析的前提，如果不符合正态分布，则需要对数据进行转换。常用的转化方式有：
取根号取对数取倒数今天我们看一看什么条件下应该选用合适的转换方式。
# 生成正态分布数据normal &amp;lt;- rnorm(100,mean = 5, sd = 2.5)plot(normal)# 从直方图可以看出数据符合正态分布hist(normal)# 从QQ plot也可以看出来qqnorm(normal)对正态数据进行平方运算后，直方图显示数据成了左偏的结构。反过来，意味着如果你正在使用的数据与下面的数据分布类似，则可以尝试用开平方的方法来做数据标准化。
# 数据的平方根normal_square &amp;lt;- normal ^ 2# 现在的直方图hist(normal_square)对正态数据进行幂值运算后，数值也是一个左偏的分布，但与平方计算的结构有所不同。
# 数据的幂值normal_exp &amp;lt;- exp(normal)hist(normal_exp)对正态数据进行倒数运算后，数值是一个中间翘起来的分布。
# 数据的幂值normal_reciprocal &amp;lt;- 1/normalhist(normal_reciprocal)上述3种方法转换正态分布后，都是正偏态数据（偏度Skewness &amp;gt; 0 ）。
如果是负偏态数据，则需要将负偏态资料进行反转，转换为正偏态，然后再参考正偏态分布资料的转换方法进行转换。
反转的方法：首先找出该数据系列的最大值max，用max+1，在减去每个数值。
接下来也用反向转换的方式，看看负偏态数据的分布规律吧。
# 轻度负偏态normal_square_rev &amp;lt;- max(normal_square)+1-normal_squarehist(normal_square_rev)# 中度负偏态normal_exp_rev &amp;lt;- max(normal_exp)+1-normal_exphist(normal_exp_rev)# 重度负偏态normal_reciprocal_rev &amp;lt;- max(normal_reciprocal) + 1 - normal_reciprocalhist(normal_reciprocal_rev)注意事项：</description>
    </item>
    
    <item>
      <title>ANOVA &#43; TurkeyHSD 分析及作图</title>
      <link>/post/2019/09/24/anova-turkeyhsd-plotting/</link>
      <pubDate>Tue, 24 Sep 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/2019/09/24/anova-turkeyhsd-plotting/</guid>
      <description>先载入一个示例数据。该数据是研究摄入 VC 对小鼠牙齿生长作用的实验结果。VC 给药分成两种方式：VC-给予VC药片；OJ-给予相当量的橙汁。给药的量都包括0.5,1,2等三个梯度。
从散点图上看，不同给药量之间应该有显著差异。
data(&amp;quot;ToothGrowth&amp;quot;)head(ToothGrowth)## len supp dose## 1 4.2 VC 0.5## 2 11.5 VC 0.5## 3 7.3 VC 0.5## 4 5.8 VC 0.5## 5 6.4 VC 0.5## 6 10.0 VC 0.5dim(ToothGrowth)## [1] 60 3library(ggplot2)ggplot(ToothGrowth,aes(factor(dose),len)) + geom_boxplot(outlier.shape = NULL) + geom_jitter() +facet_wrap(~supp)单因素方差分析使用 aov() 函数，随后，进一步使用 HSD.test 获取组间差异。 Tukey’s ‘Honest Significant Difference’ method 通常使用 stats::TukeyHSD() 函数， 但在这里，我们使用 HSD.</description>
    </item>
    
    <item>
      <title>比较不同差异系数的结果</title>
      <link>/post/2018/11/20/comparing-dissimilarity-index/</link>
      <pubDate>Tue, 20 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/2018/11/20/comparing-dissimilarity-index/</guid>
      <description>vegdist 提供了多个计算差异度的算法。这些算法自然是各有各的适用范围。对于同一个数据集，其结果有什么直观上的差异呢？
library(vegan) library(pheatmap) library(cowplot) data(&amp;quot;varespec&amp;quot;) dist.methods &amp;lt;- c(&amp;quot;manhattan&amp;quot;, &amp;quot;euclidean&amp;quot;, &amp;quot;canberra&amp;quot;, &amp;quot;clark&amp;quot;, &amp;quot;bray&amp;quot;, &amp;quot;kulczynski&amp;quot;, &amp;quot;jaccard&amp;quot;, &amp;quot;gower&amp;quot;, &amp;quot;altGower&amp;quot;, &amp;quot;morisita&amp;quot;, &amp;quot;horn&amp;quot;, &amp;quot;mountford&amp;quot;, &amp;quot;raup&amp;quot;, &amp;quot;binomial&amp;quot;, &amp;quot;chao&amp;quot;, &amp;quot;cao&amp;quot; , &amp;quot;mahalanobis&amp;quot;) 对于这17种方法，分别计算其距离，用 pheatmap() 比较其差异。
dist.plots &amp;lt;- vector(&amp;quot;list&amp;quot;,length(dist.methods)) for (i in seq_along(dist.methods)){ dist &amp;lt;- vegdist(varespec,method = dist.methods[[i]]) plot &amp;lt;- pheatmap(dist,cluster_cols = F,cluster_rows = F,main = dist.methods[[i]],silent = T) dist.plots[[i]] = plot[[4]] } ## Warning in vegdist(varespec, method = dist.methods[[i]]): results may be ## meaningless with non-integer data in method &amp;quot;morisita&amp;quot; ## Warning in vegdist(varespec, method = dist.</description>
    </item>
    
    <item>
      <title>比较 stats::procmp() 和 vegan::rda() 两种方法</title>
      <link>/post/2018/11/02/comparison-of-two-pca-methods/</link>
      <pubDate>Fri, 02 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/2018/11/02/comparison-of-two-pca-methods/</guid>
      <description>上次提及 PCA 分析的方法有很多种。那不同方法之间的得到的结果会有差异吗？
最近采用 PCA 分析 RNA-seq 样本之间的差异，得到了下面的结果。
生成示例数据 生成一个含有 1000 个基因, 27 个样品的数据集. 这 27 个样品来自于 3 个基因型(WT, Mutant1, Mutant2), 3 种处理(CK, Trt1, Trt2), 共分为 \(3 * 3 = 9\) 组, 每组 3 个重复, 合计 27 个样品.
library(DESeq2) library(dplyr) library(ggplot2) theme_set(theme_bw()) dds &amp;lt;- makeExampleDESeqDataSet(n = 1000, m=27) dds$condition &amp;lt;- factor(rep(rep(c(&amp;quot;Ctrl&amp;quot;,&amp;quot;Trt1&amp;quot;,&amp;quot;Trt2&amp;quot;),3), 3)) dds$genotype &amp;lt;- factor(rep(rep(c(&amp;quot;WT&amp;quot;,&amp;quot;MuA&amp;quot;,&amp;quot;MuB&amp;quot;), each=3),3)) # sample table sample_table &amp;lt;- colData(dds) %&amp;gt;% as.data.frame() %&amp;gt;% tibble::rownames_to_column(var=&amp;quot;sample_id&amp;quot;) # 做 log2 变换 rld &amp;lt;- rlog(dds, blind = F) 使用 stats::prcomp() 进行主成分分析 # 运行 PCA pca &amp;lt;- stats::prcomp(t(assay(rld))) # 计算解释度 percent_var &amp;lt;- pca$sdev^2/sum(pca$sdev^2) # 绘图 df &amp;lt;- data.</description>
    </item>
    
    <item>
      <title>Bray Curtis Dissimilarity</title>
      <link>/post/2018/10/17/bray-curtis-dissimilarity/</link>
      <pubDate>Wed, 17 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/2018/10/17/bray-curtis-dissimilarity/</guid>
      <description>本文介绍 Bray Curtis Dissimilarity 的概念和计算方法。
Bray Curtis Dissimilarity（Bray-Curtis 相异度）是生态学中用来衡量不同样地物种组成差异的参数。
其定义和计算公式为：
$$BC_{ij}=1-2C_{ij}/(S_{i}+S_{j})$$
其中：
\(i\) 和 \(j\) 是两个样地； \(S_i\) 是样地 \(i\) 中物种的总数； \(S_j\) 是样地 \(j\) 中物种的总数； \(C_{ij}\) 在两块样地中每个物种的较少计数的总和。 简单的例子 有两个水族箱：
一号：6条金鱼，7条孔雀鱼和4只螃蟹； 二号：10条金鱼和6只螃蟹。 为了计算 Bray-Curtis，首先计算$C_{ij}$。金鱼两个地方都有，较少的是6；孔雀鱼只在一号中有，所以不能添加；螃蟹两个地方都有，较少的是4。因此，$C_{ij}=6+4=10$。
\(S_i=6+7+4=17\)，而$S_j=10+6=16$。
因此,
$$BC_{ij}=1-(2*10)/(17+16)=0.39$$
Bray-Curtis Dissimilarity 的性质 其取值介于0-1之间。如果是0，则两个样地共享所有相同的物种；如果是1，则它们不共享任何物种。
还有另外一个 Bray-Curtis index，其取值是 1 - Bray-Curtis dissimilarity。表示两个样地之间的相似程度。
适用情况 要计算 Bray-Curtis Dissimilarity，必须假设两个样地的面积或体积大小相同（与物种计数相关），否则需要在计算前调整计数。
R语言实现 vegan提供了vegdist来计算这个数值。
## 用 vegdist 重复上面的例子 df &amp;lt;- data.frame(goldfish=c(6,10),guppies=c(7,0),crab=c(4,6)) require(&amp;quot;vegan&amp;quot;) ## 载入需要的程辑包：vegan ## 载入需要的程辑包：permute ## 载入需要的程辑包：lattice ## This is vegan 2.</description>
    </item>
    
  </channel>
</rss>
